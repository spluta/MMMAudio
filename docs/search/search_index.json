{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MMMAudio Documentation","text":"<p>Welcome to the MMMAudio documentation! MMMAudio is a high-performance audio processing library that combines the ease of Python with the speed of Mojo for real-time audio applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>High Performance: Leverages Mojo's SIMD capabilities for optimal audio processing</li> <li>Dual Language Support: Write audio logic in Python, optimize critical paths in Mojo</li> <li>Real-time Capable: Designed for low-latency audio applications</li> <li>Modular Design: Composable DSP building blocks</li> <li>ML Integration: Support for neural network audio processing</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation and basic usage</li> <li>API Reference: Complete API documentation</li> <li>Examples: Practical usage examples</li> <li>Contributing: Contributing and development guide</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>MMMAudio is built around a graph-based processing model where audio flows through connected nodes. Each node can be implemented in either Python (for flexibility) or Mojo (for performance).</p>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>DSP Modules (<code>mmm_dsp</code>): Basic audio processing building blocks</li> <li>Framework (<code>mmm_src</code>): Audio engine and graph management</li> <li>Utilities (<code>mmm_utils</code>): Mathematical and utility functions</li> </ul>"},{"location":"#why","title":"Why","text":""},{"location":"#why-python","title":"Why Python?","text":""},{"location":"#why-mojo","title":"Why Mojo?","text":""},{"location":"#community","title":"Community","text":"<ul> <li>GitHub: https://github.com/spluta/MMMAudio</li> <li>Issues: Report bugs and feature requests on GitHub</li> </ul>"},{"location":"getting-started/","title":"Getting Started with MMMAudio","text":"<p>MMMAudio is a high-performance audio processing library that combines Python's ease of use with Mojo's performance for real-time audio applications.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Mojo compiler (latest version)</li> <li>Audio drivers (ASIO on Windows, CoreAudio on macOS, ALSA on Linux)</li> </ul>"},{"location":"getting-started/#install-from-source","title":"Install from Source","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/tedmoore/MMMAudio.git\ncd MMMAudio\n</code></pre> <ol> <li>Install Python dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Verify Mojo installation:</li> </ol> <pre><code>mojo --version\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#basic-audio-setup","title":"Basic Audio Setup","text":"<p>Create a simple audio processing chain:</p> <pre><code>from mmm_src.MMMAudio import MMMAudio\nfrom mmm_dsp.Osc import SineOsc\n\n# Initialize audio engine\naudio = MMMAudio(\n    sample_rate=44100,\n    buffer_size=512,\n    channels=2\n)\n\n# Create a sine wave oscillator\nosc = SineOsc(frequency=440.0, amplitude=0.5)\n\n# Connect oscillator to audio output\naudio.connect(osc, audio.output)\n\n# Start audio processing\naudio.start()\n\n# Let it run for 5 seconds\nimport time\ntime.sleep(5)\n\n# Stop audio\naudio.stop()\n</code></pre>"},{"location":"getting-started/#using-mojo-for-performance","title":"Using Mojo for Performance","text":"<p>For performance-critical operations, use Mojo implementations:</p> <pre><code>from mmm_utils.functions import linlin\nfrom algorithm import parallelize\n\n# Process control data with SIMD optimization\nmidi_velocities = [64, 80, 96, 127]  # MIDI velocity values\ngains = []\n\nfor velocity in midi_velocities:\n    # Convert MIDI velocity to linear gain using Mojo function\n    gain = linlin(float(velocity), 0.0, 127.0, 0.0, 1.0)\n    gains.append(gain)\n\nprint(f\"Converted gains: {gains}\")\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#audio-graph","title":"Audio Graph","text":"<p>MMMAudio uses a graph-based processing model where audio flows through connected nodes:</p> <pre><code># Create nodes\ninput_node = audio.input\nosc1 = SineOsc(440.0)\nosc2 = SineOsc(880.0)\nmixer = Mixer(2)  # 2-input mixer\noutput_node = audio.output\n\n# Connect the graph\naudio.connect(osc1, mixer.input[0])\naudio.connect(osc2, mixer.input[1])\naudio.connect(mixer, output_node)\n</code></pre>"},{"location":"getting-started/#simd-optimization","title":"SIMD Optimization","text":"<p>Mojo functions support SIMD operations for processing multiple values simultaneously:</p> <pre><code># Process 4 frequencies at once\nfrom mmm_utils.functions import midicps\n\nmidi_notes = SIMD[DType.float64, 4](60.0, 64.0, 67.0, 72.0)  # C major chord\nfrequencies = midicps[4](midi_notes)  # Convert to frequencies\n</code></pre>"},{"location":"getting-started/#real-time-processing","title":"Real-time Processing","text":"<p>MMMAudio is designed for real-time audio with low latency:</p> <pre><code># Configure for low latency\naudio = MMMAudio(\n    sample_rate=44100,\n    buffer_size=128,  # Small buffer for low latency\n    channels=2\n)\n\n# Use efficient processing chains\nreverb = Reverb(room_size=0.5, damping=0.7)\naudio.connect(audio.input, reverb)\naudio.connect(reverb, audio.output)\n</code></pre>"},{"location":"getting-started/#examples","title":"Examples","text":""},{"location":"getting-started/#simple-synthesizer","title":"Simple Synthesizer","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\nfrom mmm_dsp.Osc import SineOsc\nfrom mmm_dsp.Env import ADSR\nfrom mmm_dsp.Filters import LowPass\n\n# Create audio engine\naudio = MMMAudio()\n\n# Create synthesis components\nosc = SineOsc(frequency=440.0)\nenvelope = ADSR(attack=0.1, decay=0.2, sustain=0.7, release=0.5)\nfilter = LowPass(cutoff=2000.0, resonance=0.5)\n\n# Build signal chain\naudio.connect(osc, filter)\naudio.connect(envelope, filter.cutoff_mod)  # Envelope modulates filter\naudio.connect(filter, audio.output)\n\n# Start synthesis\naudio.start()\nenvelope.trigger()  # Trigger note\n\ntime.sleep(2)\nenvelope.release()  # Release note\ntime.sleep(1)\n\naudio.stop()\n</code></pre>"},{"location":"getting-started/#multi-channel-processing","title":"Multi-channel Processing","text":"<pre><code># Stereo processing with different effects per channel\naudio = MMMAudio(channels=2)\n\n# Create stereo sources\nosc_left = SineOsc(440.0)\nosc_right = SineOsc(442.0)  # Slightly detuned for stereo effect\n\n# Different processing per channel\ndelay_left = Delay(time=0.3, feedback=0.3)\ndelay_right = Delay(time=0.4, feedback=0.2)\n\n# Connect stereo processing\naudio.connect(osc_left, delay_left)\naudio.connect(osc_right, delay_right)\naudio.connect(delay_left, audio.output.left)\naudio.connect(delay_right, audio.output.right)\n\naudio.start()\n</code></pre>"},{"location":"getting-started/#performance-tips","title":"Performance Tips","text":""},{"location":"getting-started/#use-simd-when-possible","title":"Use SIMD When Possible","text":"<pre><code># Instead of processing one value at a time:\nfor i in range(len(values)):\n    result[i] = linlin(values[i], 0.0, 1.0, 20.0, 20000.0)\n\n# Process multiple values with SIMD:\nfrom mmm_utils.functions import linlin\n\n# Convert list to SIMD and process all at once\nvalues_simd = SIMD[DType.float64, 4].from_list(values[:4])\nresults_simd = linlin[4](values_simd, 0.0, 1.0, 20.0, 20000.0)\n</code></pre>"},{"location":"getting-started/#optimize-buffer-sizes","title":"Optimize Buffer Sizes","text":"<pre><code># Balance latency vs CPU usage\naudio = MMMAudio(\n    buffer_size=256,  # Good balance for most applications\n    sample_rate=44100\n)\n\n# For very low latency (may increase CPU usage):\naudio_low_latency = MMMAudio(buffer_size=64)\n\n# For maximum efficiency (higher latency):\naudio_efficient = MMMAudio(buffer_size=1024)\n</code></pre>"},{"location":"getting-started/#reuse-objects","title":"Reuse Objects","text":"<pre><code># Create objects once and reuse\nosc = SineOsc()\n\n# Change parameters instead of creating new objects\nosc.set_frequency(880.0)\nosc.set_amplitude(0.5)\n\n# This is more efficient than:\n# osc = SineOsc(frequency=880.0, amplitude=0.5)  # Creates new object\n</code></pre>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#audio-dropouts","title":"Audio Dropouts","text":"<p>If you experience audio dropouts:</p> <ol> <li> <p>Increase buffer size:    <pre><code>audio = MMMAudio(buffer_size=512)  # or higher\n</code></pre></p> </li> <li> <p>Reduce processing complexity in real-time callbacks</p> </li> <li> <p>Use Mojo implementations for CPU-intensive operations</p> </li> </ol>"},{"location":"getting-started/#import-errors","title":"Import Errors","text":"<p>Make sure the project is in your Python path:</p> <pre><code>import sys\nsys.path.append('/path/to/MMMAudio')\n</code></pre> <p>Or install in development mode:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"getting-started/#mojo-compilation-issues","title":"Mojo Compilation Issues","text":"<p>Ensure you have the latest Mojo compiler:</p> <pre><code>mojo --version\n</code></pre> <p>Update if necessary according to Mojo documentation.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed function documentation</li> <li>Check out Examples for more complex usage patterns</li> <li>Read the Development Guide to contribute</li> </ul>"},{"location":"getting-started/#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discussions: Questions and community interaction</li> <li>Documentation: Complete API reference and guides</li> </ul> <p>Happy audio processing with MMMAudio!</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the complete API reference for MMMAudio, organized by module.</p>"},{"location":"api/#core-dsp-mmm_dsp","title":"Core DSP (<code>mmm_dsp</code>)","text":"<p>The core DSP modules provide the fundamental building blocks for audio processing:</p> <ul> <li>Utilities: Mathematical utility functions</li> <li>Oscillators: Sine, square, sawtooth, and noise generators</li> <li>Filters: Low-pass, high-pass, band-pass filters</li> <li>Envelopes: ADSR and other envelope generators</li> <li>Delays: Delay lines and echo effects</li> <li>Buffers: Audio buffer management</li> <li>Effects: Distortion and saturation</li> </ul>"},{"location":"api/#framework-mmm_src","title":"Framework (<code>mmm_src</code>)","text":"<p>The framework modules handle audio engine management and processing:</p> <ul> <li>Audio Engine: Main audio processing engine</li> <li>Graph System: Audio graph management</li> <li>Traits: Core interfaces and traits</li> <li>Scheduler: Event scheduling and timing</li> </ul>"},{"location":"api/#utilities-mmm_utils","title":"Utilities (<code>mmm_utils</code>)","text":"<p>Utility modules provide mathematical functions and helpers:</p> <ul> <li>Functions: Mathematical utility functions</li> <li>FFT: Fast Fourier Transform utilities</li> <li>Windows: Window functions for DSP</li> </ul>"},{"location":"api/#documentation-conventions","title":"Documentation Conventions","text":""},{"location":"api/#function-signatures","title":"Function Signatures","text":"<p>Functions are documented with their complete signatures including type information:</p> <pre><code>fn linlin[N: Int = 1](\n    value: SIMD[DType.float64, N], \n    in_min: SIMD[DType.float64, N], \n    in_max: SIMD[DType.float64, N], \n    out_min: SIMD[DType.float64, N], \n    out_max: SIMD[DType.float64, N]\n) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/#simd-support","title":"SIMD Support","text":"<p>Most functions support SIMD operations for processing multiple values simultaneously. The <code>N</code> parameter controls the SIMD width.</p>"},{"location":"api/#examples","title":"Examples","text":"<p>Each function includes practical examples showing typical usage patterns.</p>"},{"location":"api/mmm_dsp/Buffer/","title":"Buffer","text":""},{"location":"api/mmm_dsp/Buffer/#buffer_1","title":"Buffer","text":"<p>Has 2 possible constructors:</p> <p>1) Buffer(lists: List[List[Float64]], buf_sample_rate: Float64 = 48000.0).    - lists: List of channels, each channel is a List of Float64 samples.    - buf_sample_rate: Sample rate of the buffer (default is 48000.0).</p> <p>2) Buffer(num_chans: Int64 = 2, samples: Int64 = 48000, buf_sample_rate: Float64 = 48000.0).    - num_chans: Number of channels (default is 2 for stereo).    - samples: Number of samples per channel (default is 48000 for 1 second at 48kHz).    - buf_sample_rate: Sample rate of the buffer (default is 48000.0).</p> <p>Parent Traits: <code>AnyType</code>, <code>Buffable</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Buffer/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Buffer/#fn-get_num_frames","title":"<code>fn</code> get_num_frames","text":"<p>Return the number of frames in the buffer.</p>"},{"location":"api/mmm_dsp/Buffer/#signature","title":"Signature","text":"<pre><code>get_num_frames(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#returns","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-get_duration","title":"<code>fn</code> get_duration","text":"<p>Return the duration of the buffer in seconds.</p>"},{"location":"api/mmm_dsp/Buffer/#signature_1","title":"Signature","text":"<pre><code>get_duration(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-get_buf_sample_rate","title":"<code>fn</code> get_buf_sample_rate","text":"<p>Return the sample rate of the buffer.</p>"},{"location":"api/mmm_dsp/Buffer/#signature_2","title":"Signature","text":"<pre><code>get_buf_sample_rate(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-quadratic_interp_loc","title":"<code>fn</code> quadratic_interp_loc","text":""},{"location":"api/mmm_dsp/Buffer/#signature_3","title":"Signature","text":"<pre><code>quadratic_interp_loc(self, idx: Int64, idx1: Int64, idx2: Int64, frac: Float64, chan: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#arguments","title":"Arguments","text":"<ul> <li>idx: <code>Int64</code> </li> <li>idx1: <code>Int64</code> </li> <li>idx2: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> <li>chan: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#returns_3","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-linear_interp_loc","title":"<code>fn</code> linear_interp_loc","text":""},{"location":"api/mmm_dsp/Buffer/#signature_4","title":"Signature","text":"<pre><code>linear_interp_loc(self, idx: Int64, idx1: Int64, frac: Float64, chan: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#arguments_1","title":"Arguments","text":"<ul> <li>idx: <code>Int64</code> </li> <li>idx1: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> <li>chan: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#returns_4","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-read_sinc","title":"<code>fn</code> read_sinc","text":""},{"location":"api/mmm_dsp/Buffer/#signature_5","title":"Signature","text":"<pre><code>read_sinc(mut self, chan: Int64, phase: Float64, last_phase: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#arguments_2","title":"Arguments","text":"<ul> <li>chan: <code>Int64</code> </li> <li>phase: <code>Float64</code> </li> <li>last_phase: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#returns_5","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-read","title":"<code>fn</code> read","text":"<p>A read operation on the buffer that reads a multichannel buffer and returns a SIMD vector of size N. It will start reading from the channel specified by start_chan and read N channels from there.read(start_chan, phase, interp=0)</p>"},{"location":"api/mmm_dsp/Buffer/#signature_6","title":"Signature","text":"<pre><code>read[N: Int = 1](mut self, start_chan: Int64, phase: Float64, interp: Int64 = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - The number of channels to read (default is 1). The SIMD vector returned will have this size as well.  </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#arguments_3","title":"Arguments","text":"<ul> <li>start_chan: <code>Int64</code> - The starting channel index to read from (0-based).  </li> <li>phase: <code>Float64</code> - The phase position to read from, where 0.0 is the start of the buffer and 1.0 is the end.  </li> <li>interp: <code>Int64</code> = <code>0</code> - The interpolation method to use (0 = linear, 1 = quadratic).  </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#returns_6","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Buffer/#fn-write","title":"<code>fn</code> write","text":""},{"location":"api/mmm_dsp/Buffer/#signature_7","title":"Signature","text":"<pre><code>write[N: Int = 1](mut self, value: SIMD[DType.float64, N], index: Int64, start_channel: Int64 = 0)\n</code></pre>"},{"location":"api/mmm_dsp/Buffer/#parameters_1","title":"Parameters","text":"<ul> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/Buffer/#arguments_4","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> </li> <li>index: <code>Int64</code> </li> <li>start_channel: <code>Int64</code> = <code>0</code> </li> </ul> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Delays/","title":"Delays","text":""},{"location":"api/mmm_dsp/Delays/#delay","title":"Delay","text":"<p>A delay line with Lagrange interpolation.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Delays/#parameters","title":"Parameters","text":"<ol> <li>N: <code>Int</code> - size of the SIMD vector - defaults to 1</li> </ol>"},{"location":"api/mmm_dsp/Delays/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Delays/#fn-next","title":"<code>fn</code> next","text":"<p>Process one sample through the delay line. This function computes the average of two values.next(input, delay_time)</p>"},{"location":"api/mmm_dsp/Delays/#signature","title":"Signature","text":"<pre><code>next(mut self, input: SIMD[DType.float64, N], delay_time: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Delays/#arguments","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> - The input sample to process.  </li> <li>delay_time: <code>SIMD</code> - The amount of delay to apply (in seconds).  </li> </ul>"},{"location":"api/mmm_dsp/Delays/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code> The processed output sample.</p>"},{"location":"api/mmm_dsp/Delays/#fn-lagrange4","title":"<code>fn</code> lagrange4","text":"<p>Perform Lagrange interpolation for 4th order case (from JOS Faust Model).</p>"},{"location":"api/mmm_dsp/Delays/#signature_1","title":"Signature","text":"<pre><code>lagrange4(mut self, input: SIMD[DType.float64, N], delay_time: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Delays/#arguments_1","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>delay_time: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Delays/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### Comb</p> <p>A simple comb filter using a delay line with feedback.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Delays/#parameters_1","title":"Parameters","text":"<ol> <li>N: <code>Int</code> - size of the SIMD vector - defaults to 1</li> </ol>"},{"location":"api/mmm_dsp/Delays/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Delays/#fn-next_1","title":"<code>fn</code> next","text":"<p>Process one sample through the comb filter.next(input, delay_time=0.0, feedback=0.0, interp=0)</p>"},{"location":"api/mmm_dsp/Delays/#signature_2","title":"Signature","text":"<pre><code>next(mut self, input: SIMD[DType.float64, N], delay_time: SIMD[DType.float64, N] = 0, feedback: SIMD[DType.float64, N] = 0, interp: Int64 = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Delays/#arguments_2","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> - The input sample to process.  </li> <li>delay_time: <code>SIMD</code> = <code>0</code> - The amount of delay to apply (in seconds).  </li> <li>feedback: <code>SIMD</code> = <code>0</code> - The amount of feedback to apply (0.0 to 1.0).  </li> <li>interp: <code>Int64</code> = <code>0</code> - The interpolation method to use (0 = linear, 1 = cubic, 2 = Lagrange).  </li> </ul>"},{"location":"api/mmm_dsp/Delays/#returns_2","title":"Returns","text":"<p>Type: <code>SIMD</code> The processed output sample.</p> <p>---### FBDelay</p> <p>Like a Comb filter but with any amount of feedback and a tanh function.</p> <pre><code>Parameters:\n  N: size of the SIMD vector - defaults to 1\n</code></pre> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Delays/#parameters_2","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Delays/#functions_2","title":"Functions","text":""},{"location":"api/mmm_dsp/Delays/#fn-next_2","title":"<code>fn</code> next","text":"<p>Process one sample or SIMD vector through the feedback delay.next(input, delay_time=0.0, feedback=0.0, interp=0)</p>"},{"location":"api/mmm_dsp/Delays/#signature_3","title":"Signature","text":"<pre><code>next(mut self, input: SIMD[DType.float64, N], delay_time: SIMD[DType.float64, N], feedback: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Delays/#arguments_3","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> - The input sample to process.  </li> <li>delay_time: <code>SIMD</code> - The amount of delay to apply (in seconds).  </li> <li>feedback: <code>SIMD</code> - The amount of feedback to apply (0.0 to 1.0).  </li> </ul>"},{"location":"api/mmm_dsp/Delays/#returns_3","title":"Returns","text":"<p>Type: <code>SIMD</code> The processed output sample or SIMD vector.</p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Distortion/","title":"Distortion","text":""},{"location":"api/mmm_dsp/Distortion/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Distortion/#vtanh","title":"vtanh","text":""},{"location":"api/mmm_dsp/Distortion/#signature","title":"Signature","text":"<pre><code>vtanh(in_samp: Float64, gain: Float64, offset: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Distortion/#arguments","title":"Arguments","text":"<ul> <li>in_samp: <code>Float64</code>- gain: <code>Float64</code>- offset: <code>Float64</code></li> </ul>"},{"location":"api/mmm_dsp/Distortion/#returns","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Distortion/#bitcrusher","title":"bitcrusher","text":""},{"location":"api/mmm_dsp/Distortion/#signature_1","title":"Signature","text":"<pre><code>bitcrusher(in_samp: Float64, bits: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Distortion/#arguments_1","title":"Arguments","text":"<ul> <li>in_samp: <code>Float64</code>- bits: <code>Int64</code></li> </ul>"},{"location":"api/mmm_dsp/Distortion/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/Distortion/#latch","title":"Latch","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Distortion/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Distortion/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Distortion/#signature_2","title":"Signature","text":"<pre><code>next(mut self, in_samp: Float64, trig: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Distortion/#arguments_2","title":"Arguments","text":"<ul> <li>in_samp: <code>Float64</code> </li> <li>trig: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Distortion/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Env/","title":"Env","text":"<p>Envelope generator module.</p> <p>This module provides an envelope generator class that can create complex envelopes with multiple segments, curves, and looping capabilities.</p>"},{"location":"api/mmm_dsp/Env/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Env/#min_env","title":"min_env","text":"<p>Create a minimum envelope with specified ramp and duration.</p>"},{"location":"api/mmm_dsp/Env/#signature","title":"Signature","text":"<pre><code>min_env[N: Int = 1](ramp: SIMD[DType.float64, N] = 0.01, dur: SIMD[DType.float64, N] = 0.10000000000000001, rise: SIMD[DType.float64, N] = 0.001) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Env/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_dsp/Env/#arguments","title":"Arguments","text":"<ul> <li>ramp: <code>SIMD</code> = <code>0.01</code>- dur: <code>SIMD</code> = <code>0.10000000000000001</code>- rise: <code>SIMD</code> = <code>0.001</code></li> </ul>"},{"location":"api/mmm_dsp/Env/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Env/#env_1","title":"Env","text":"<p>Envelope generator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Env/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Env/#fn-reset_vals","title":"<code>fn</code> reset_vals","text":"<p>Reset internal values.</p>"},{"location":"api/mmm_dsp/Env/#signature_1","title":"Signature","text":"<pre><code>reset_vals(mut self, times: List[Float64])\n</code></pre>"},{"location":"api/mmm_dsp/Env/#arguments_1","title":"Arguments","text":"<ul> <li>times: <code>List</code> </li> </ul>"},{"location":"api/mmm_dsp/Env/#fn-next","title":"<code>fn</code> next","text":"<p>Generate the next envelope sample.</p>"},{"location":"api/mmm_dsp/Env/#signature_2","title":"Signature","text":"<pre><code>next(mut self, values: List[Float64] = List[Float64, False](0, 1, 0, Tuple[]()), times: List[Float64] = List[Float64, False](1, 1, Tuple[]()), curves: List[Float64] = List[Float64, False](1, Tuple[]()), loop: Int64 = 0, trig: Float64 = 1, time_warp: Float64 = 1) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Env/#arguments_2","title":"Arguments","text":"<ul> <li>values: <code>List</code> = <code>List[Float64, False](0, 1, 0, Tuple[]())</code> </li> <li>times: <code>List</code> = <code>List[Float64, False](1, 1, Tuple[]())</code> </li> <li>curves: <code>List</code> = <code>List[Float64, False](1, Tuple[]())</code> </li> <li>loop: <code>Int64</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>1</code> </li> <li>time_warp: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/Env/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Filters/","title":"Filters","text":""},{"location":"api/mmm_dsp/Filters/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#tf2s","title":"tf2s","text":""},{"location":"api/mmm_dsp/Filters/#signature","title":"Signature","text":"<pre><code>tf2s[N: Int = 1](coeffs: List[SIMD[DType.float64, N]], mut coeffs_out: List[SIMD[DType.float64, N]], sample_rate: Float64)\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_dsp/Filters/#arguments","title":"Arguments","text":"<ul> <li>coeffs: <code>List</code>- coeffs_out: <code>List</code>- sample_rate: <code>Float64</code></li> </ul>"},{"location":"api/mmm_dsp/Filters/#lag","title":"Lag","text":"<p>A lag processor that smooths input values over time based on a specified lag time in seconds.</p> <p>Arguments:</p> <pre><code>**N:** Number of channels Lag will process. (This creates SIMD parallel processing.)\n</code></pre> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_1","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-get_small_simd","title":"<code>fn</code> get_small_simd","text":""},{"location":"api/mmm_dsp/Filters/#signature_1","title":"Signature","text":"<pre><code>get_small_simd(mut self, in_samp: SIMD[DType.float64, N], j: Int)\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_1","title":"Arguments","text":"<ul> <li>in_samp: <code>SIMD</code> </li> <li>j: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#fn-put_small_simd","title":"<code>fn</code> put_small_simd","text":""},{"location":"api/mmm_dsp/Filters/#signature_2","title":"Signature","text":"<pre><code>put_small_simd(mut self, j: Int)\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_2","title":"Arguments","text":"<ul> <li>j: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Filters/#signature_3","title":"Signature","text":"<pre><code>next(mut self: Lag[N], var in_samp: SIMD[DType.float64, N], lag: SIMD[DType.float64, N] = 0.050000000000000003, num_lags: Int = $0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_3","title":"Arguments","text":"<ul> <li>in_samp: <code>SIMD</code> </li> <li>lag: <code>SIMD</code> = <code>0.050000000000000003</code> </li> <li>num_lags: <code>Int</code> = <code>$0</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### SVF</p> <p>State Variable Filter implementation translated from Oleg Nesterov's Faust implementation</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_2","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_2","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-reset","title":"<code>fn</code> reset","text":"<p>Reset internal state</p>"},{"location":"api/mmm_dsp/Filters/#signature_4","title":"Signature","text":"<pre><code>reset(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#fn-next_1","title":"<code>fn</code> next","text":"<p>next a single sample through the SVF</p>"},{"location":"api/mmm_dsp/Filters/#signature_5","title":"Signature","text":"<pre><code>next(mut self, input: SIMD[DType.float64, N], filter_type: SIMD[DType.int32, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain_db: SIMD[DType.float64, N] = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_4","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>filter_type: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain_db: <code>SIMD</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-lpf","title":"<code>fn</code> lpf","text":"<p>Lowpass filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_6","title":"Signature","text":"<pre><code>lpf(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_5","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_2","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-bpf","title":"<code>fn</code> bpf","text":"<p>Bandpass filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_7","title":"Signature","text":"<pre><code>bpf(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_6","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_3","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-hpf","title":"<code>fn</code> hpf","text":"<p>Highpass filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_8","title":"Signature","text":"<pre><code>hpf(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_7","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_4","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-notch","title":"<code>fn</code> notch","text":"<p>Notch filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_9","title":"Signature","text":"<pre><code>notch(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_8","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_5","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-peak","title":"<code>fn</code> peak","text":"<p>Peak filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_10","title":"Signature","text":"<pre><code>peak(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_9","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_6","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-allpass","title":"<code>fn</code> allpass","text":"<p>Allpass filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_11","title":"Signature","text":"<pre><code>allpass(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_10","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_7","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-bell","title":"<code>fn</code> bell","text":"<p>Bell filter (parametric EQ)</p>"},{"location":"api/mmm_dsp/Filters/#signature_12","title":"Signature","text":"<pre><code>bell(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain_db: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_11","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain_db: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_8","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-lowshelf","title":"<code>fn</code> lowshelf","text":"<p>Low shelf filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_13","title":"Signature","text":"<pre><code>lowshelf(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain_db: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_12","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain_db: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_9","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-highshelf","title":"<code>fn</code> highshelf","text":"<p>High shelf filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_14","title":"Signature","text":"<pre><code>highshelf(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain_db: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_13","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain_db: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_10","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### lpf_LR4</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_3","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_3","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-set_sample_rate","title":"<code>fn</code> set_sample_rate","text":""},{"location":"api/mmm_dsp/Filters/#signature_15","title":"Signature","text":"<pre><code>set_sample_rate(mut self, sample_rate: Float64)\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_14","title":"Arguments","text":"<ul> <li>sample_rate: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#fn-next_2","title":"<code>fn</code> next","text":"<p>a single sample through the 4th order lowpass filter.</p>"},{"location":"api/mmm_dsp/Filters/#signature_16","title":"Signature","text":"<pre><code>next(mut self, input: SIMD[DType.float64, N], frequency: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_15","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>frequency: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_11","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### OnePole</p> <p>Simple one-pole IIR filter that can be configured as lowpass or highpass</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#functions_4","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_3","title":"<code>fn</code> next","text":"<p>Process one sample through the filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_17","title":"Signature","text":"<pre><code>next(mut self, input: Float64, coef: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_16","title":"Arguments","text":"<ul> <li>input: <code>Float64</code> </li> <li>coef: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_12","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### Integrator</p> <p>Simple one-pole IIR filter that can be configured as lowpass or highpass</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#functions_5","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_4","title":"<code>fn</code> next","text":"<p>Process one sample through the filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_18","title":"Signature","text":"<pre><code>next(mut self, input: Float64, coef: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_17","title":"Arguments","text":"<ul> <li>input: <code>Float64</code> </li> <li>coef: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_13","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### DCTrap</p> <p>DC Trap from Digital Sound Generation by Beat Frei.</p> <p>Arguments:     input: The input signal to process.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_4","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_6","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_5","title":"<code>fn</code> next","text":"<p>Process one sample through the DC blocker filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_19","title":"Signature","text":"<pre><code>next(mut self, in_: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_18","title":"Arguments","text":"<ul> <li>in_: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_14","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### VAOnePole</p> <p>Simple one-pole IIR filter that can be configured as lowpass or highpass}</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_5","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_7","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-lpf_1","title":"<code>fn</code> lpf","text":"<p>Process one sample through the filter</p>"},{"location":"api/mmm_dsp/Filters/#signature_20","title":"Signature","text":"<pre><code>lpf(mut self, input: SIMD[DType.float64, N], freq: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_19","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_15","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-hpf_1","title":"<code>fn</code> hpf","text":""},{"location":"api/mmm_dsp/Filters/#signature_21","title":"Signature","text":"<pre><code>hpf(mut self, input: SIMD[DType.float64, N], freq: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_20","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_16","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### VAMoogLadder</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_6","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_8","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_6","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Filters/#signature_22","title":"Signature","text":"<pre><code>next(mut self, sig: SIMD[DType.float64, N], freq: SIMD[DType.float64, N], q_val: SIMD[DType.float64, N], os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_21","title":"Arguments","text":"<ul> <li>sig: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> <li>q_val: <code>SIMD</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_17","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### FIR</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_7","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_9","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_7","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Filters/#signature_23","title":"Signature","text":"<pre><code>next(mut self: FIR[N], input: SIMD[DType.float64, N], coeffs: List[SIMD[DType.float64, N]]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_22","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>coeffs: <code>List</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_18","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### IIR</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_8","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_10","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_8","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Filters/#signature_24","title":"Signature","text":"<pre><code>next(mut self: IIR[N], input: SIMD[DType.float64, N], coeffsbv: List[SIMD[DType.float64, N]], coeffsav: List[SIMD[DType.float64, N]]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_23","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>coeffsbv: <code>List</code> </li> <li>coeffsav: <code>List</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_19","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### tf2</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_9","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_11","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-next_9","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Filters/#signature_25","title":"Signature","text":"<pre><code>next(mut self: tf2[N], input: SIMD[DType.float64, N], coeffs: List[SIMD[DType.float64, N]]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_24","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>coeffs: <code>List</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_20","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### Reson</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Filters/#parameters_10","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Filters/#functions_12","title":"Functions","text":""},{"location":"api/mmm_dsp/Filters/#fn-lpf_2","title":"<code>fn</code> lpf","text":""},{"location":"api/mmm_dsp/Filters/#signature_26","title":"Signature","text":"<pre><code>lpf(mut self: Reson[N], input: SIMD[DType.float64, N], freq: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_25","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_21","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-hpf_2","title":"<code>fn</code> hpf","text":""},{"location":"api/mmm_dsp/Filters/#signature_27","title":"Signature","text":"<pre><code>hpf(mut self: Reson[N], input: SIMD[DType.float64, N], freq: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_26","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_22","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Filters/#fn-bpf_1","title":"<code>fn</code> bpf","text":""},{"location":"api/mmm_dsp/Filters/#signature_28","title":"Signature","text":"<pre><code>bpf(mut self: Reson[N], input: SIMD[DType.float64, N], freq: SIMD[DType.float64, N], q: SIMD[DType.float64, N], gain: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Filters/#arguments_27","title":"Arguments","text":"<ul> <li>input: <code>SIMD</code> </li> <li>freq: <code>SIMD</code> </li> <li>q: <code>SIMD</code> </li> <li>gain: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Filters/#returns_23","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/InterleavedBuffer/","title":"InterleavedBuffer","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#interleavedbuffer_1","title":"InterleavedBuffer","text":"<p>An audio buffer that loads data from a WAV file using SciPy and NumPy. The data is stored in an interleaved format.</p> <p>Parent Traits: <code>AnyType</code>, <code>Buffable</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-get_num_frames","title":"<code>fn</code> get_num_frames","text":"<p>Return the number of frames in the buffer.</p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#signature","title":"Signature","text":"<pre><code>get_num_frames(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-get_duration","title":"<code>fn</code> get_duration","text":"<p>Return the duration of the buffer in seconds.</p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_1","title":"Signature","text":"<pre><code>get_duration(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-get_buf_sample_rate","title":"<code>fn</code> get_buf_sample_rate","text":"<p>Return the sample rate of the buffer.</p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_2","title":"Signature","text":"<pre><code>get_buf_sample_rate(self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-load_file","title":"<code>fn</code> load_file","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_3","title":"Signature","text":"<pre><code>load_file(mut self, filename: String) -&gt; PythonObject\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#arguments","title":"Arguments","text":"<ul> <li>filename: <code>String</code> </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_3","title":"Returns","text":"<p>Type: <code>PythonObject</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#raises","title":"Raises","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-quadratic_interp_loc","title":"<code>fn</code> quadratic_interp_loc","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_4","title":"Signature","text":"<pre><code>quadratic_interp_loc(self, idx: Int64, idx1: Int64, idx2: Int64, frac: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#arguments_1","title":"Arguments","text":"<ul> <li>idx: <code>Int64</code> </li> <li>idx1: <code>Int64</code> </li> <li>idx2: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_4","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-linear_interp_loc","title":"<code>fn</code> linear_interp_loc","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_5","title":"Signature","text":"<pre><code>linear_interp_loc(self, idx: Int64, idx1: Int64, frac: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#arguments_2","title":"Arguments","text":"<ul> <li>idx: <code>Int64</code> </li> <li>idx1: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_5","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-next_sinc","title":"<code>fn</code> next_sinc","text":""},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_6","title":"Signature","text":"<pre><code>next_sinc(mut self, chan: Int64, phase: Float64, last_phase: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#arguments_3","title":"Arguments","text":"<ul> <li>chan: <code>Int64</code> </li> <li>phase: <code>Float64</code> </li> <li>last_phase: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_6","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#fn-read","title":"<code>fn</code> read","text":"<p>A read operation on the buffer that reads a multichannel buffer and returns a SIMD vector of size N.read(start_chan, phase, interp=0)</p>"},{"location":"api/mmm_dsp/InterleavedBuffer/#signature_7","title":"Signature","text":"<pre><code>read[N: Int = 1](mut self, start_chan: Int64, phase: Float64, interp: Int64 = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/InterleavedBuffer/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - The number of channels to read (default is 1). The SIMD vector returned will have this size as well.  </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#arguments_4","title":"Arguments","text":"<ul> <li>start_chan: <code>Int64</code> - The starting channel index to read from (0-based).  </li> <li>phase: <code>Float64</code> - The phase position to read from, where 0.0 is the start of the buffer and 1.0 is the end.  </li> <li>interp: <code>Int64</code> = <code>0</code> - The interpolation method to use (0 = linear, 1 = quadratic).  </li> </ul>"},{"location":"api/mmm_dsp/InterleavedBuffer/#returns_7","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/MLP/","title":"MLP","text":""},{"location":"api/mmm_dsp/MLP/#mlp_1","title":"MLP","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/MLP/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/MLP/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/MLP/#signature","title":"Signature","text":"<pre><code>next[N: Int = 16](mut self, input: List[Float64]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/MLP/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/MLP/#arguments","title":"Arguments","text":"<ul> <li>input: <code>List</code> </li> </ul>"},{"location":"api/mmm_dsp/MLP/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/MLP/#raises","title":"Raises","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Noise/","title":"Noise","text":""},{"location":"api/mmm_dsp/Noise/#whitenoise","title":"WhiteNoise","text":"<p>Generate white noise samples.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Noise/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Noise/#fn-next","title":"<code>fn</code> next","text":"<p>Generate the next white noise sample.</p>"},{"location":"api/mmm_dsp/Noise/#signature","title":"Signature","text":"<pre><code>next(self, gain: Float64 = 1) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Noise/#arguments","title":"Arguments","text":"<ul> <li>gain: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/Noise/#returns","title":"Returns","text":"<p>Type: <code>Float64</code> A random value between -gain and gain.</p> <p>---### PinkNoise</p> <p>Generate pink noise samples.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Noise/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Noise/#fn-next_1","title":"<code>fn</code> next","text":"<p>Generate the next pink noise sample.</p>"},{"location":"api/mmm_dsp/Noise/#signature_1","title":"Signature","text":"<pre><code>next(mut self, gain: Float64 = 1) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Noise/#arguments_1","title":"Arguments","text":"<ul> <li>gain: <code>Float64</code> = <code>1</code> - Amplitude scaling factor.  </li> </ul>"},{"location":"api/mmm_dsp/Noise/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### BrownNoise</p> <p>Generate brown noise samples.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Noise/#functions_2","title":"Functions","text":""},{"location":"api/mmm_dsp/Noise/#fn-next_2","title":"<code>fn</code> next","text":"<p>Generate the next brown noise sample.</p>"},{"location":"api/mmm_dsp/Noise/#signature_2","title":"Signature","text":"<pre><code>next(mut self, gain: Float64 = 1) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Noise/#arguments_2","title":"Arguments","text":"<ul> <li>gain: <code>Float64</code> = <code>1</code> - Amplitude scaling factor.  </li> </ul>"},{"location":"api/mmm_dsp/Noise/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code> A brown noise sample scaled by gain.</p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Osc/","title":"Osc","text":""},{"location":"api/mmm_dsp/Osc/#phasor","title":"Phasor","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-increment_phase","title":"<code>fn</code> increment_phase","text":""},{"location":"api/mmm_dsp/Osc/#signature","title":"Signature","text":"<pre><code>increment_phase(mut self: Phasor[N], freq: SIMD[DType.float64, N], os_index: Int = 0)\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_1","title":"Signature","text":"<pre><code>next(mut self: Phasor[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_1","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### Osc</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_1","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_1","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_2","title":"Signature","text":"<pre><code>next(mut self: Osc[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, osc_type: SIMD[DType.int64, N] = 0, interp: SIMD[DType.int64, N] = 1, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_2","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>osc_type: <code>SIMD</code> = <code>0</code> </li> <li>interp: <code>SIMD</code> = <code>1</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Osc/#fn-next_interp","title":"<code>fn</code> next_interp","text":""},{"location":"api/mmm_dsp/Osc/#signature_3","title":"Signature","text":"<pre><code>next_interp(mut self: Osc[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, osc_types: List[Int64] = List[Int64, False](0, 4, 5, 6, Tuple[]()), osc_frac: SIMD[DType.float64, N] = 0, interp: Int64 = 1, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_3","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>osc_types: <code>List</code> = <code>List[Int64, False](0, 4, 5, 6, Tuple[]())</code> </li> <li>osc_frac: <code>SIMD</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>1</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_2","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### SinOsc</p> <p>A sine wave oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_2","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_2","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_2","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_4","title":"Signature","text":"<pre><code>next(mut self: SinOsc[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, interp: Int64 = 0, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_4","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_3","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### LFSaw</p> <p>A low-frequency sawtooth oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_3","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_3","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_3","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_5","title":"Signature","text":"<pre><code>next(mut self: LFSaw[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, interp: Int64 = 0, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_5","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_4","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### LFSquare</p> <p>A low-frequency square wave oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_4","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_4","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_4","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_6","title":"Signature","text":"<pre><code>next(mut self: LFSquare[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, interp: Int64 = 0, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_6","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_5","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### LFTri</p> <p>A low-frequency triangle wave oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_5","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_5","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_5","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_7","title":"Signature","text":"<pre><code>next(mut self: LFTri[N], freq: SIMD[DType.float64, N] = 100, phase_offset: SIMD[DType.float64, N] = 0, trig: Float64 = 0, interp: Int64 = 0, os_index: Int = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_7","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>phase_offset: <code>SIMD</code> = <code>0</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> <li>os_index: <code>Int</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_6","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### Impulse</p> <p>An oscillator that generates an impulse signal. Arguments:     world_ptr: Pointer to the MMMWorld instance.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_6","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_6","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_6","title":"<code>fn</code> next","text":"<p>Generate the next impulse sample.</p>"},{"location":"api/mmm_dsp/Osc/#signature_8","title":"Signature","text":"<pre><code>next(mut self: Impulse[N], freq: SIMD[DType.float64, N] = 100, trig: Float64 = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_8","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_7","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Osc/#fn-get_phase","title":"<code>fn</code> get_phase","text":""},{"location":"api/mmm_dsp/Osc/#signature_9","title":"Signature","text":"<pre><code>get_phase(mut self: Impulse[N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#returns_8","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### Dust</p> <p>A low-frequency dust noise oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#parameters_7","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Osc/#functions_7","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_7","title":"<code>fn</code> next","text":"<p>Generate the next dust noise sample.</p>"},{"location":"api/mmm_dsp/Osc/#signature_10","title":"Signature","text":"<pre><code>next(mut self: Dust[N], freq: SIMD[DType.float64, N] = 100, trig: Float64 = 1) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_9","title":"Arguments","text":"<ul> <li>freq: <code>SIMD</code> = <code>100</code> </li> <li>trig: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_9","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Osc/#fn-next_range","title":"<code>fn</code> next_range","text":"<p>Generate the next dust noise sample.</p>"},{"location":"api/mmm_dsp/Osc/#signature_11","title":"Signature","text":"<pre><code>next_range(mut self: Dust[N], low: SIMD[DType.float64, N] = 100, high: SIMD[DType.float64, N] = 2000, trig: Float64 = 1) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_10","title":"Arguments","text":"<ul> <li>low: <code>SIMD</code> = <code>100</code> </li> <li>high: <code>SIMD</code> = <code>2000</code> </li> <li>trig: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_10","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/Osc/#fn-get_phase_1","title":"<code>fn</code> get_phase","text":""},{"location":"api/mmm_dsp/Osc/#signature_12","title":"Signature","text":"<pre><code>get_phase(mut self: Dust[N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#returns_11","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### LFNoise</p> <p>Low-frequency noise oscillator.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#functions_8","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-next_8","title":"<code>fn</code> next","text":"<p>Generate the next low-frequency noise sample.</p>"},{"location":"api/mmm_dsp/Osc/#signature_13","title":"Signature","text":"<pre><code>next(mut self, freq: Float64 = 100, interp: Int64 = 0) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_11","title":"Arguments","text":"<ul> <li>freq: <code>Float64</code> = <code>100</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_12","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### Sweep</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Osc/#functions_9","title":"Functions","text":""},{"location":"api/mmm_dsp/Osc/#fn-increment_phase_1","title":"<code>fn</code> increment_phase","text":""},{"location":"api/mmm_dsp/Osc/#signature_14","title":"Signature","text":"<pre><code>increment_phase(mut self, freq: Float64)\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_12","title":"Arguments","text":"<ul> <li>freq: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#fn-next_9","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Osc/#signature_15","title":"Signature","text":"<pre><code>next(mut self, freq: Float64 = 100, trig: Float64 = 0) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/Osc/#arguments_13","title":"Arguments","text":"<ul> <li>freq: <code>Float64</code> = <code>100</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/Osc/#returns_13","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/OscBuffers/","title":"OscBuffers","text":""},{"location":"api/mmm_dsp/OscBuffers/#sinc_interpolator","title":"Sinc_Interpolator","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/OscBuffers/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature","title":"Signature","text":"<pre><code>next(self, sp: Int64, sinc_offset: Int64, sinc_mult: Int64, frac: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments","title":"Arguments","text":"<ul> <li>sp: <code>Int64</code> </li> <li>sinc_offset: <code>Int64</code> </li> <li>sinc_mult: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### OscBuffers</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/OscBuffers/#fn-init_sine","title":"<code>fn</code> init_sine","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_1","title":"Signature","text":"<pre><code>init_sine(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_triangle","title":"<code>fn</code> init_triangle","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_2","title":"Signature","text":"<pre><code>init_triangle(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_sawtooth","title":"<code>fn</code> init_sawtooth","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_3","title":"Signature","text":"<pre><code>init_sawtooth(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_square","title":"<code>fn</code> init_square","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_4","title":"Signature","text":"<pre><code>init_square(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_triangle2","title":"<code>fn</code> init_triangle2","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_5","title":"Signature","text":"<pre><code>init_triangle2(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_sawtooth2","title":"<code>fn</code> init_sawtooth2","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_6","title":"Signature","text":"<pre><code>init_sawtooth2(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-init_square2","title":"<code>fn</code> init_square2","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_7","title":"Signature","text":"<pre><code>init_square2(mut self)\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#fn-quadratic_interp_loc","title":"<code>fn</code> quadratic_interp_loc","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_8","title":"Signature","text":"<pre><code>quadratic_interp_loc(self, x: Float64, buf_num: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_1","title":"Arguments","text":"<ul> <li>x: <code>Float64</code> </li> <li>buf_num: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-lerp","title":"<code>fn</code> lerp","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_9","title":"Signature","text":"<pre><code>lerp(self, x: Float64, buf_num: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_2","title":"Arguments","text":"<ul> <li>x: <code>Float64</code> </li> <li>buf_num: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-read_lin","title":"<code>fn</code> read_lin","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_10","title":"Signature","text":"<pre><code>read_lin(self, phase: Float64, buf_num: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_3","title":"Arguments","text":"<ul> <li>phase: <code>Float64</code> </li> <li>buf_num: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_3","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-read_quadratic","title":"<code>fn</code> read_quadratic","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_11","title":"Signature","text":"<pre><code>read_quadratic(self, phase: Float64, buf_num: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_4","title":"Arguments","text":"<ul> <li>phase: <code>Float64</code> </li> <li>buf_num: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_4","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-read_sinc","title":"<code>fn</code> read_sinc","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_12","title":"Signature","text":"<pre><code>read_sinc(self, phase: Float64, last_phase: Float64, buf_num: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_5","title":"Arguments","text":"<ul> <li>phase: <code>Float64</code> </li> <li>last_phase: <code>Float64</code> </li> <li>buf_num: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_5","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-spaced_sinc","title":"<code>fn</code> spaced_sinc","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_13","title":"Signature","text":"<pre><code>spaced_sinc(self, buf_num: Int64, index: Int64, frac: Float64, spacing: Int64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_6","title":"Arguments","text":"<ul> <li>buf_num: <code>Int64</code> </li> <li>index: <code>Int64</code> </li> <li>frac: <code>Float64</code> </li> <li>spacing: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_6","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/OscBuffers/#fn-read","title":"<code>fn</code> read","text":""},{"location":"api/mmm_dsp/OscBuffers/#signature_14","title":"Signature","text":"<pre><code>read(self, phase: Float64, osc_type: Int64 = 0, interp: Int64 = 0) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/OscBuffers/#arguments_7","title":"Arguments","text":"<ul> <li>phase: <code>Float64</code> </li> <li>osc_type: <code>Int64</code> = <code>0</code> </li> <li>interp: <code>Int64</code> = <code>0</code> </li> </ul>"},{"location":"api/mmm_dsp/OscBuffers/#returns_7","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Oversampling/","title":"Oversampling","text":""},{"location":"api/mmm_dsp/Oversampling/#oversampling_1","title":"Oversampling","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Oversampling/#parameters","title":"Parameters","text":"<ol> <li>N: <code>Int</code></li> </ol>"},{"location":"api/mmm_dsp/Oversampling/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Oversampling/#fn-set_os_index","title":"<code>fn</code> set_os_index","text":""},{"location":"api/mmm_dsp/Oversampling/#signature","title":"Signature","text":"<pre><code>set_os_index(mut self, index: Int)\n</code></pre>"},{"location":"api/mmm_dsp/Oversampling/#arguments","title":"Arguments","text":"<ul> <li>index: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/Oversampling/#fn-add_sample","title":"<code>fn</code> add_sample","text":"<p>Add a sample to the oversampling buffer.</p>"},{"location":"api/mmm_dsp/Oversampling/#signature_1","title":"Signature","text":"<pre><code>add_sample(mut self, sample: SIMD[DType.float64, N])\n</code></pre>"},{"location":"api/mmm_dsp/Oversampling/#arguments_1","title":"Arguments","text":"<ul> <li>sample: <code>SIMD</code> </li> </ul>"},{"location":"api/mmm_dsp/Oversampling/#fn-get_sample","title":"<code>fn</code> get_sample","text":"<p>get the next sample from a filled oversampling buffer.</p>"},{"location":"api/mmm_dsp/Oversampling/#signature_2","title":"Signature","text":"<pre><code>get_sample(mut self) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Oversampling/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/Pan/","title":"Pan","text":""},{"location":"api/mmm_dsp/Pan/#pan2","title":"Pan2","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Pan/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/Pan/#fn-next","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Pan/#signature","title":"Signature","text":"<pre><code>next(mut self, sample: Float64, mut pan: Float64) -&gt; SIMD[DType.float64, 2]\n</code></pre>"},{"location":"api/mmm_dsp/Pan/#arguments","title":"Arguments","text":"<ul> <li>sample: <code>Float64</code> </li> <li>pan: <code>Float64</code> </li> </ul>"},{"location":"api/mmm_dsp/Pan/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### PanAz</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/Pan/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/Pan/#fn-next_1","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/Pan/#signature_1","title":"Signature","text":"<pre><code>next[N: Int](mut self, sample: Float64, pan: Float64, num_speakers: Int64, width: Float64 = 2, orientation: Float64 = 0.5) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/Pan/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/Pan/#arguments_1","title":"Arguments","text":"<ul> <li>sample: <code>Float64</code> </li> <li>pan: <code>Float64</code> </li> <li>num_speakers: <code>Int64</code> </li> <li>width: <code>Float64</code> = <code>2</code> </li> <li>orientation: <code>Float64</code> = <code>0.5</code> </li> </ul>"},{"location":"api/mmm_dsp/Pan/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/PlayBuf/","title":"PlayBuf","text":""},{"location":"api/mmm_dsp/PlayBuf/#playbuf_1","title":"PlayBuf","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/PlayBuf/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/PlayBuf/#fn-next","title":"<code>fn</code> next","text":"<p>get the next sample from an audio buffer - can take both Buffer or InterleavedBuffer.Arguments:     buffer: The audio buffer to read from (can be Buffer or InterleavedBuffer).     rate: The playback rate. 1 is the normal speed of the buffer.     loop: Whether to loop the buffer (default: True).     trig: Trigger starts the synth at start_frame (default: 1.0).     start_frame: The start frame for playback (default: 0) upon receiving a trigger.     end_frame: The end frame for playback (default: -1).</p>"},{"location":"api/mmm_dsp/PlayBuf/#signature","title":"Signature","text":"<pre><code>next[T: Buffable, N: Int = 1](mut self, mut buffer: T, start_chan: Int, rate: Float64, loop: Bool = True, trig: Float64 = 1, start_frame: Float64 = 0, end_frame: Float64 = -1) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_dsp/PlayBuf/#parameters","title":"Parameters","text":"<ul> <li>T: <code>Buffable</code> </li> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#arguments","title":"Arguments","text":"<ul> <li>buffer: <code>T</code> </li> <li>start_chan: <code>Int</code> </li> <li>rate: <code>Float64</code> </li> <li>loop: <code>Bool</code> = <code>True</code> </li> <li>trig: <code>Float64</code> = <code>1</code> </li> <li>start_frame: <code>Float64</code> = <code>0</code> </li> <li>end_frame: <code>Float64</code> = <code>-1</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_dsp/PlayBuf/#fn-get_phase","title":"<code>fn</code> get_phase","text":""},{"location":"api/mmm_dsp/PlayBuf/#signature_1","title":"Signature","text":"<pre><code>get_phase(mut self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/PlayBuf/#returns_1","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_dsp/PlayBuf/#fn-get_win_phase","title":"<code>fn</code> get_win_phase","text":""},{"location":"api/mmm_dsp/PlayBuf/#signature_2","title":"Signature","text":"<pre><code>get_win_phase(mut self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_dsp/PlayBuf/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>---### Grain</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/PlayBuf/#functions_1","title":"Functions","text":""},{"location":"api/mmm_dsp/PlayBuf/#fn-next_1","title":"<code>fn</code> next","text":""},{"location":"api/mmm_dsp/PlayBuf/#signature_3","title":"Signature","text":"<pre><code>next[T: Buffable, N: Int = 1](mut self, mut buffer: T, start_chan: Int, trig: Float64 = 0, rate: Float64 = 1, start_frame: Float64 = 0, duration: Float64 = 0, pan: Float64 = 0, gain: Float64 = 1) -&gt; SIMD[DType.float64, 2]\n</code></pre>"},{"location":"api/mmm_dsp/PlayBuf/#parameters_1","title":"Parameters","text":"<ul> <li>T: <code>Buffable</code> </li> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#arguments_1","title":"Arguments","text":"<ul> <li>buffer: <code>T</code> </li> <li>start_chan: <code>Int</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>rate: <code>Float64</code> = <code>1</code> </li> <li>start_frame: <code>Float64</code> = <code>0</code> </li> <li>duration: <code>Float64</code> = <code>0</code> </li> <li>pan: <code>Float64</code> = <code>0</code> </li> <li>gain: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#returns_3","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>---### TGrains</p> <p>Triggered granular synthesis. Each trigger starts a new grain.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/PlayBuf/#functions_2","title":"Functions","text":""},{"location":"api/mmm_dsp/PlayBuf/#fn-next_2","title":"<code>fn</code> next","text":"<p>Generate the next set of grains.Arguments:.     buffer: Audio buffer containing the source sound.     trig: Trigger signal (&gt;0 to start a new grain).     rate: Playback rate of the grains (1.0 = normal speed).     start_frame: Starting frame position in the buffer.     duration: Duration of each grain in seconds.     pan: Panning position from -1.0 (left) to 1.0 (right).     gain: Amplitude scaling factor for the grains.</p>"},{"location":"api/mmm_dsp/PlayBuf/#signature_4","title":"Signature","text":"<pre><code>next[T: Buffable, N: Int = 1](mut self, mut buffer: T, buf_chan: Int, trig: Float64 = 0, rate: Float64 = 1, start_frame: Float64 = 0, duration: Float64 = 0.10000000000000001, pan: Float64 = 0, gain: Float64 = 1) -&gt; SIMD[DType.float64, 2]\n</code></pre>"},{"location":"api/mmm_dsp/PlayBuf/#parameters_2","title":"Parameters","text":"<ul> <li>T: <code>Buffable</code> </li> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#arguments_2","title":"Arguments","text":"<ul> <li>buffer: <code>T</code> </li> <li>buf_chan: <code>Int</code> </li> <li>trig: <code>Float64</code> = <code>0</code> </li> <li>rate: <code>Float64</code> = <code>1</code> </li> <li>start_frame: <code>Float64</code> = <code>0</code> </li> <li>duration: <code>Float64</code> = <code>0.10000000000000001</code> </li> <li>pan: <code>Float64</code> = <code>0</code> </li> <li>gain: <code>Float64</code> = <code>1</code> </li> </ul>"},{"location":"api/mmm_dsp/PlayBuf/#returns_4","title":"Returns","text":"<p>Type: <code>SIMD</code> List of output samples for all channels.</p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/RecordBuf/","title":"RecordBuf","text":""},{"location":"api/mmm_dsp/RecordBuf/#recordbuf_1","title":"RecordBuf","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_dsp/RecordBuf/#functions","title":"Functions","text":""},{"location":"api/mmm_dsp/RecordBuf/#fn-write","title":"<code>fn</code> write","text":""},{"location":"api/mmm_dsp/RecordBuf/#signature","title":"Signature","text":"<pre><code>write[N: Int = 1](mut self, value: SIMD[DType.float64, N], mut buffer: Buffer)\n</code></pre>"},{"location":"api/mmm_dsp/RecordBuf/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> </li> </ul>"},{"location":"api/mmm_dsp/RecordBuf/#arguments","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> </li> <li>buffer: <code>Buffer</code> </li> </ul> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_dsp/__init__/","title":"init","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_src/MMMGraphs/","title":"MMMGraphs","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_src/MMMTraits/","title":"MMMTraits","text":""},{"location":"api/mmm_src/MMMTraits/#traits","title":"Traits","text":""},{"location":"api/mmm_src/MMMTraits/#graphable","title":"Graphable","text":""},{"location":"api/mmm_src/MMMTraits/#signature","title":"Signature","text":""},{"location":"api/mmm_src/MMMTraits/#required-methods","title":"Required Methods","text":""},{"location":"api/mmm_src/MMMTraits/#next","title":"next","text":""},{"location":"api/mmm_src/MMMTraits/#signature_1","title":"Signature","text":"<pre><code>next(mut self: _Self) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_src/MMMTraits/#arguments","title":"Arguments","text":"<ul> <li>self: <code>_Self</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#returns","title":"Returns","text":"<p>Type: <code>List</code></p>"},{"location":"api/mmm_src/MMMTraits/#buffable","title":"Buffable","text":""},{"location":"api/mmm_src/MMMTraits/#signature_2","title":"Signature","text":""},{"location":"api/mmm_src/MMMTraits/#required-methods_1","title":"Required Methods","text":""},{"location":"api/mmm_src/MMMTraits/#read","title":"read","text":""},{"location":"api/mmm_src/MMMTraits/#signature_3","title":"Signature","text":"<pre><code>read[N: Int = 1](mut self: _Self, start_chan: Int64, phase: Float64, interp: Int64 = 0) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_src/MMMTraits/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#arguments_1","title":"Arguments","text":"<ul> <li>self: <code>_Self</code>- start_chan: <code>Int64</code>- phase: <code>Float64</code>- interp: <code>Int64</code> = <code>0</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_src/MMMTraits/#get_num_frames","title":"get_num_frames","text":""},{"location":"api/mmm_src/MMMTraits/#signature_4","title":"Signature","text":"<pre><code>get_num_frames(self: _Self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_src/MMMTraits/#arguments_2","title":"Arguments","text":"<ul> <li>self: <code>_Self</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#returns_2","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_src/MMMTraits/#get_duration","title":"get_duration","text":""},{"location":"api/mmm_src/MMMTraits/#signature_5","title":"Signature","text":"<pre><code>get_duration(self: _Self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_src/MMMTraits/#arguments_3","title":"Arguments","text":"<ul> <li>self: <code>_Self</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#returns_3","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_src/MMMTraits/#get_buf_sample_rate","title":"get_buf_sample_rate","text":""},{"location":"api/mmm_src/MMMTraits/#signature_6","title":"Signature","text":"<pre><code>get_buf_sample_rate(self: _Self) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_src/MMMTraits/#arguments_4","title":"Arguments","text":"<ul> <li>self: <code>_Self</code></li> </ul>"},{"location":"api/mmm_src/MMMTraits/#returns_4","title":"Returns","text":"<p>Type: <code>Float64</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_src/MMMWorld/","title":"MMMWorld","text":""},{"location":"api/mmm_src/MMMWorld/#mmmworld_1","title":"MMMWorld","text":"<p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_src/MMMWorld/#functions","title":"Functions","text":""},{"location":"api/mmm_src/MMMWorld/#fn-set_channel_count","title":"<code>fn</code> set_channel_count","text":""},{"location":"api/mmm_src/MMMWorld/#signature","title":"Signature","text":"<pre><code>set_channel_count(mut self, num_in_chans: Int64, num_out_chans: Int64)\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments","title":"Arguments","text":"<ul> <li>num_in_chans: <code>Int64</code> </li> <li>num_out_chans: <code>Int64</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#fn-send_msg","title":"<code>fn</code> send_msg","text":""},{"location":"api/mmm_src/MMMWorld/#signature_1","title":"Signature","text":"<pre><code>send_msg(mut self, key: String, mut list: List[Float64])\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_1","title":"Arguments","text":"<ul> <li>key: <code>String</code> </li> <li>list: <code>List</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#fn-get_msg","title":"<code>fn</code> get_msg","text":""},{"location":"api/mmm_src/MMMWorld/#signature_2","title":"Signature","text":"<pre><code>get_msg(mut self, key: String) -&gt; Optional[List[Float64]]\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_2","title":"Arguments","text":"<ul> <li>key: <code>String</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#returns","title":"Returns","text":"<p>Type: <code>Optional</code></p>"},{"location":"api/mmm_src/MMMWorld/#fn-send_text_msg","title":"<code>fn</code> send_text_msg","text":""},{"location":"api/mmm_src/MMMWorld/#signature_3","title":"Signature","text":"<pre><code>send_text_msg(mut self, key: String, mut list: List[String])\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_3","title":"Arguments","text":"<ul> <li>key: <code>String</code> </li> <li>list: <code>List</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#fn-get_text_msg","title":"<code>fn</code> get_text_msg","text":""},{"location":"api/mmm_src/MMMWorld/#signature_4","title":"Signature","text":"<pre><code>get_text_msg(mut self, key: String) -&gt; Optional[List[String]]\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_4","title":"Arguments","text":"<ul> <li>key: <code>String</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#returns_1","title":"Returns","text":"<p>Type: <code>Optional</code></p>"},{"location":"api/mmm_src/MMMWorld/#fn-get_midi","title":"<code>fn</code> get_midi","text":""},{"location":"api/mmm_src/MMMWorld/#signature_5","title":"Signature","text":"<pre><code>get_midi(mut self, key: String, chan: Int64 = -1, param: Int64 = -1) -&gt; Optional[List[List[Int64]]]\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_5","title":"Arguments","text":"<ul> <li>key: <code>String</code> </li> <li>chan: <code>Int64</code> = <code>-1</code> </li> <li>param: <code>Int64</code> = <code>-1</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#returns_2","title":"Returns","text":"<p>Type: <code>Optional</code></p>"},{"location":"api/mmm_src/MMMWorld/#fn-clear_midi","title":"<code>fn</code> clear_midi","text":""},{"location":"api/mmm_src/MMMWorld/#signature_6","title":"Signature","text":"<pre><code>clear_midi(mut self)\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#fn-send_midi","title":"<code>fn</code> send_midi","text":""},{"location":"api/mmm_src/MMMWorld/#signature_7","title":"Signature","text":"<pre><code>send_midi(mut self, msg: PythonObject)\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#arguments_6","title":"Arguments","text":"<ul> <li>msg: <code>PythonObject</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#raises","title":"Raises","text":""},{"location":"api/mmm_src/MMMWorld/#fn-clear_msgs","title":"<code>fn</code> clear_msgs","text":""},{"location":"api/mmm_src/MMMWorld/#signature_8","title":"Signature","text":"<pre><code>clear_msgs(mut self)\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#fn-print","title":"<code>fn</code> print","text":""},{"location":"api/mmm_src/MMMWorld/#signature_9","title":"Signature","text":"<pre><code>print[T: Writable](mut self, value: T, label: String = \"\", freq: Float64 = 10)\n</code></pre>"},{"location":"api/mmm_src/MMMWorld/#parameters","title":"Parameters","text":"<ul> <li>T: <code>Writable</code> </li> </ul>"},{"location":"api/mmm_src/MMMWorld/#arguments_7","title":"Arguments","text":"<ul> <li>value: <code>T</code> </li> <li>label: <code>String</code> = <code>\"\"</code> </li> <li>freq: <code>Float64</code> = <code>10</code> </li> </ul> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_src/__init__/","title":"init","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/MMM_FFT/","title":"MMM_FFT","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/MMM_FFT2/","title":"MMM_FFT2","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/Print/","title":"Print","text":""},{"location":"api/mmm_utils/Print/#print_1","title":"Print","text":"<p>A struct for printing values in the MMMWorld environment.</p> <p>Parent Traits: <code>AnyType</code>, <code>Copyable</code>, <code>Movable</code>, <code>Representable</code>, <code>UnknownDestructibility</code></p>"},{"location":"api/mmm_utils/Print/#functions","title":"Functions","text":""},{"location":"api/mmm_utils/Print/#fn-next","title":"<code>fn</code> next","text":"<p>Print the value at a given frequency.Arguments:     value: The value to print.     label: An optional label to prepend to the printed value.     freq: The frequency (in Hz) at which to print the value.</p>"},{"location":"api/mmm_utils/Print/#signature","title":"Signature","text":"<pre><code>next[T: Writable](mut self, value: T, label: String = \"\", freq: Float64 = 10)\n</code></pre>"},{"location":"api/mmm_utils/Print/#parameters","title":"Parameters","text":"<ul> <li>T: <code>Writable</code> </li> </ul>"},{"location":"api/mmm_utils/Print/#arguments","title":"Arguments","text":"<ul> <li>value: <code>T</code> </li> <li>label: <code>String</code> = <code>\"\"</code> </li> <li>freq: <code>Float64</code> = <code>10</code> </li> </ul> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/Windows/","title":"Windows","text":""},{"location":"api/mmm_utils/Windows/#functions","title":"Functions","text":""},{"location":"api/mmm_utils/Windows/#bessel_i0","title":"bessel_i0","text":"<p>Calculate the modified Bessel function of the first kind, order 0 (I\u2080). Uses polynomial approximation for accurate results.</p>"},{"location":"api/mmm_utils/Windows/#signature","title":"Signature","text":"<pre><code>bessel_i0(x: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments","title":"Arguments","text":"<ul> <li>x: <code>Float64</code> - Input value</li> </ul>"},{"location":"api/mmm_utils/Windows/#returns","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_utils/Windows/#kaiser_window","title":"kaiser_window","text":"<p>Create a Kaiser window of length n with shape parameter beta.</p>"},{"location":"api/mmm_utils/Windows/#signature_1","title":"Signature","text":"<pre><code>kaiser_window(size: Int64, beta: Float64) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments_1","title":"Arguments","text":"<ul> <li>size: <code>Int64</code>- beta: <code>Float64</code> - Shape parameter that controls the trade-off between main lobe width and side lobe level<ul> <li>beta = 0: rectangular window</li> <li>beta = 5: similar to Hamming window</li> <li>beta = 6: similar to Hanning window</li> <li>beta = 8.6: similar to Blackman window</li> </ul> </li> </ul>"},{"location":"api/mmm_utils/Windows/#returns_1","title":"Returns","text":"<p>Type: <code>List</code> DynamicVector[Float64] containing the Kaiser window coefficients</p>"},{"location":"api/mmm_utils/Windows/#build_sinc_table","title":"build_sinc_table","text":"<p>Build a sinc function lookup table.</p>"},{"location":"api/mmm_utils/Windows/#signature_2","title":"Signature","text":"<pre><code>build_sinc_table(size: Int64, ripples: Int64 = 4) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments_2","title":"Arguments","text":"<ul> <li>size: <code>Int64</code> - Number of points in the table- ripples: <code>Int64</code> = <code>4</code> - Number of ripples/lobes on each side of the main lobe</li> </ul>"},{"location":"api/mmm_utils/Windows/#returns_2","title":"Returns","text":"<p>Type: <code>List</code> List containing the sinc function values</p>"},{"location":"api/mmm_utils/Windows/#hann_window","title":"hann_window","text":"<p>Generate a Hann window of length n.</p>"},{"location":"api/mmm_utils/Windows/#signature_3","title":"Signature","text":"<pre><code>hann_window(n: Int64) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments_3","title":"Arguments","text":"<ul> <li>n: <code>Int64</code> - Length of the window</li> </ul>"},{"location":"api/mmm_utils/Windows/#returns_3","title":"Returns","text":"<p>Type: <code>List</code></p>"},{"location":"api/mmm_utils/Windows/#hamming_window","title":"hamming_window","text":"<p>Generate a Hamming window of length n.</p>"},{"location":"api/mmm_utils/Windows/#signature_4","title":"Signature","text":"<pre><code>hamming_window(n: Int64) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments_4","title":"Arguments","text":"<ul> <li>n: <code>Int64</code></li> </ul>"},{"location":"api/mmm_utils/Windows/#returns_4","title":"Returns","text":"<p>Type: <code>List</code></p>"},{"location":"api/mmm_utils/Windows/#blackman_window","title":"blackman_window","text":"<p>Generate a Blackman window of length n. Args:     n: Length of the window Returns:     List containing the Blackman window values</p>"},{"location":"api/mmm_utils/Windows/#signature_5","title":"Signature","text":"<pre><code>blackman_window(n: Int64) -&gt; List[Float64]\n</code></pre>"},{"location":"api/mmm_utils/Windows/#arguments_5","title":"Arguments","text":"<ul> <li>n: <code>Int64</code></li> </ul>"},{"location":"api/mmm_utils/Windows/#returns_5","title":"Returns","text":"<p>Type: <code>List</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/__init__/","title":"init","text":"<p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"api/mmm_utils/functions/","title":"functions","text":"<p>MMM Utility Functions</p> <p>This module provides essential utility functions for audio processing and mathematical operations in the MMMAudio framework. All functions are optimized for SIMD operations to achieve maximum performance on modern processors.</p> <p>The functions in this module include: - Range mapping functions (linear and exponential) - Clipping and wrapping utilities - Interpolation algorithms - MIDI/frequency conversion - Audio utility functions - Random number generation</p> <p>All functions support vectorized operations through SIMD types for processing multiple values simultaneously.</p>"},{"location":"api/mmm_utils/functions/#functions_1","title":"Functions","text":""},{"location":"api/mmm_utils/functions/#linlin","title":"linlin","text":"<p>Maps values from one range to another range linearly.</p> <p>This function performs linear mapping from an input range to an output range. Values outside the input range are clamped to the corresponding output boundaries. This is commonly used for scaling control values, normalizing data, and  converting between different parameter ranges.</p> <p>Examples: <pre><code># Map MIDI velocity (0-127) to gain (0.0-1.0)\nvelocity = SIMD[DType.float64, 1](64.0)\ngain = linlin(velocity, 0.0, 127.0, 0.0, 1.0)  # Returns 0.504\n\n# Map multiple control values simultaneously\ncontrols = SIMD[DType.float64, 4](0.25, 0.5, 0.75, 1.0)\nfrequencies = linlin[4](controls, 0.0, 1.0, 20.0, 20000.0)\n\n# Invert a normalized range\nnormal_vals = SIMD[DType.float64, 2](0.3, 0.7)\ninverted = linlin[2](normal_vals, 0.0, 1.0, 1.0, 0.0)\n</code></pre></p>"},{"location":"api/mmm_utils/functions/#signature","title":"Signature","text":"<pre><code>linlin[N: Int = 1](value: SIMD[DType.float64, N], in_min: SIMD[DType.float64, N], in_max: SIMD[DType.float64, N], out_min: SIMD[DType.float64, N], out_max: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector (defaults to 1).</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> - The values to map.- in_min: <code>SIMD</code> - The minimum of the input range.- in_max: <code>SIMD</code> - The maximum of the input range.- out_min: <code>SIMD</code> - The minimum of the output range.- out_max: <code>SIMD</code> - The maximum of the output range.</li> </ul>"},{"location":"api/mmm_utils/functions/#returns","title":"Returns","text":"<p>Type: <code>SIMD</code> The linearly mapped values in the output range.</p>"},{"location":"api/mmm_utils/functions/#linexp","title":"linexp","text":"<p>Maps values from one linear range to another exponential range.</p> <p>This function performs exponential mapping from a linear input range to an exponential output range. This is essential for musical applications where frequency perception is logarithmic. Both output range values must be positive.</p> <p>Examples: <pre><code># Map linear slider (0-1) to frequency range (20Hz-20kHz)\nslider_pos = SIMD[DType.float64, 1](0.5)\nfrequency = linexp(slider_pos, 0.0, 1.0, 20.0, 20000.0)  # \u2248 632 Hz\n\n# Map MIDI controller to filter cutoff frequencies\ncc_values = SIMD[DType.float64, 4](0.0, 0.33, 0.66, 1.0)\ncutoffs = linexp[4](cc_values, 0.0, 1.0, 100.0, 10000.0)\n\n# Create exponential envelope shape\nlinear_time = SIMD[DType.float64, 1](0.8)\nexp_amplitude = linexp(linear_time, 0.0, 1.0, 0.001, 1.0)\n</code></pre></p>"},{"location":"api/mmm_utils/functions/#signature_1","title":"Signature","text":"<pre><code>linexp[N: Int = 1](value: SIMD[DType.float64, N], in_min: SIMD[DType.float64, N], in_max: SIMD[DType.float64, N], out_min: SIMD[DType.float64, N], out_max: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_1","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector (defaults to 1).</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_1","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> - The values to map.- in_min: <code>SIMD</code> - The minimum of the input range.- in_max: <code>SIMD</code> - The maximum of the input range.- out_min: <code>SIMD</code> - The minimum of the output range (must be &gt; 0).- out_max: <code>SIMD</code> - The maximum of the output range (must be &gt; 0).</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_1","title":"Returns","text":"<p>Type: <code>SIMD</code> The exponentially mapped values in the output range.</p>"},{"location":"api/mmm_utils/functions/#clip","title":"clip","text":"<p>Clips each element in the SIMD vector to the specified range. Parameters:     N: Size of the SIMD vector - defaults to 1. Args:     val: The SIMD vector to clip. Each element will be clipped individually.     lo: The minimum value.     hi: The maximum value. Returns:     The clipped SIMD vector.</p>"},{"location":"api/mmm_utils/functions/#signature_2","title":"Signature","text":"<pre><code>clip[N: Int = 1](val: SIMD[DType.float64, N], lo: SIMD[DType.float64, N], hi: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_2","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_2","title":"Arguments","text":"<ul> <li>val: <code>SIMD</code>- lo: <code>SIMD</code>- hi: <code>SIMD</code></li> </ul>"},{"location":"api/mmm_utils/functions/#returns_2","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_utils/functions/#wrap","title":"wrap","text":"<p>Wraps a value around a specified range. Parameters:     N: Size of the SIMD vector - defaults to 1..</p>"},{"location":"api/mmm_utils/functions/#signature_3","title":"Signature","text":"<pre><code>wrap[N: Int = 1](value: SIMD[DType.float64, N], min_val: SIMD[DType.float64, N], max_val: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_3","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_3","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> - The value to wrap.- min_val: <code>SIMD</code> - The minimum of the range.- max_val: <code>SIMD</code> - The maximum of the range.</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_3","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Wraps a value around a specified range.</p>"},{"location":"api/mmm_utils/functions/#signature_4","title":"Signature","text":"<pre><code>wrap[N: Int = 1](value: SIMD[DType.int64, N], min_val: SIMD[DType.int64, N], max_val: SIMD[DType.int64, N]) -&gt; SIMD[DType.int64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_4","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector - defaults to 1.</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_4","title":"Arguments","text":"<ul> <li>value: <code>SIMD</code> - The value to wrap.- min_val: <code>SIMD</code> - The minimum of the range.- max_val: <code>SIMD</code> - The maximum of the range.</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_4","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_utils/functions/#quadratic_interp","title":"quadratic_interp","text":"<p>Performs quadratic interpolation between three points.</p>"},{"location":"api/mmm_utils/functions/#signature_5","title":"Signature","text":"<pre><code>quadratic_interp(y0: Float64, y1: Float64, y2: Float64, x: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_5","title":"Arguments","text":"<ul> <li>y0: <code>Float64</code> - The value at position 0.- y1: <code>Float64</code> - The value at position 1.- y2: <code>Float64</code> - The value at position 2.- x: <code>Float64</code> - The interpolation position (typically between 0 and 2).</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_5","title":"Returns","text":"<p>Type: <code>Float64</code> The interpolated value at position x.</p>"},{"location":"api/mmm_utils/functions/#cubic_interp","title":"cubic_interp","text":"<p>Performs cubic interpolation between.</p> <p>Cubic Intepolation equation from The Audio Programming Book  by Richard Boulanger and Victor Lazzarini. pg. 400</p>"},{"location":"api/mmm_utils/functions/#signature_6","title":"Signature","text":"<pre><code>cubic_interp(p0: Float64, p1: Float64, p2: Float64, p3: Float64, t: Float64) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_6","title":"Arguments","text":"<ul> <li>p0: <code>Float64</code> - Point to the left of p1.- p1: <code>Float64</code> - Point to the left of the float t.- p2: <code>Float64</code> - Point to the right of the float t.- p3: <code>Float64</code> - Point to the right of p2.- t: <code>Float64</code> - Interpolation parameter (0.0 to 1.0).</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_6","title":"Returns","text":"<p>Type: <code>Float64</code> Interpolated value.</p>"},{"location":"api/mmm_utils/functions/#lagrange4","title":"lagrange4","text":"<p>Perform Lagrange interpolation for 4th order case (from JOS Faust Model). This is extrapolated from the JOS Faust filter model.</p> <p>lagrange4N -&gt; SIMD[Float64, N]</p>"},{"location":"api/mmm_utils/functions/#signature_7","title":"Signature","text":"<pre><code>lagrange4[N: Int = 1](sample0: SIMD[DType.float64, N], sample1: SIMD[DType.float64, N], sample2: SIMD[DType.float64, N], sample3: SIMD[DType.float64, N], sample4: SIMD[DType.float64, N], frac: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_5","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector - defaults to 1.</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_7","title":"Arguments","text":"<ul> <li>sample0: <code>SIMD</code> - The first sample.- sample1: <code>SIMD</code> - The second sample.- sample2: <code>SIMD</code> - The third sample.- sample3: <code>SIMD</code> - The fourth sample.- sample4: <code>SIMD</code> - The fifth sample.- frac: <code>SIMD</code> - The fractional delay (0.0 to 1.0) which is the location between sample0 and sample1.</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_7","title":"Returns","text":"<p>Type: <code>SIMD</code> The interpolated value.</p>"},{"location":"api/mmm_utils/functions/#lerp","title":"lerp","text":"<p>Performs linear interpolation between two points.</p> <p>lerpN -&gt; Float64 or SIMD[Float64, N]</p>"},{"location":"api/mmm_utils/functions/#signature_8","title":"Signature","text":"<pre><code>lerp[N: Int = 1](p0: SIMD[DType.float64, N], p1: SIMD[DType.float64, N], t: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_6","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector - defaults to 1.</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_8","title":"Arguments","text":"<ul> <li>p0: <code>SIMD</code> - The starting point.- p1: <code>SIMD</code> - The ending point.- t: <code>SIMD</code> - The interpolation parameter (0.0 to 1.0).</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_8","title":"Returns","text":"<p>Type: <code>SIMD</code> The interpolated value.</p>"},{"location":"api/mmm_utils/functions/#midicps","title":"midicps","text":""},{"location":"api/mmm_utils/functions/#signature_9","title":"Signature","text":"<pre><code>midicps(midi_note_number: Int64, reference_midi_note: Int64 = 69, reference_frequency: Float64 = 440) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_9","title":"Arguments","text":"<ul> <li>midi_note_number: <code>Int64</code>- reference_midi_note: <code>Int64</code> = <code>69</code>- reference_frequency: <code>Float64</code> = <code>440</code></li> </ul>"},{"location":"api/mmm_utils/functions/#returns_9","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_utils/functions/#signature_10","title":"Signature","text":"<pre><code>midicps(midi_note_number: Float64, reference_midi_note: Float64 = 69, reference_frequency: Float64 = 440) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_10","title":"Arguments","text":"<ul> <li>midi_note_number: <code>Float64</code>- reference_midi_note: <code>Float64</code> = <code>69</code>- reference_frequency: <code>Float64</code> = <code>440</code></li> </ul>"},{"location":"api/mmm_utils/functions/#returns_10","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_utils/functions/#cpsmidi","title":"cpsmidi","text":""},{"location":"api/mmm_utils/functions/#signature_11","title":"Signature","text":"<pre><code>cpsmidi(freq: Float64, reference_midi_note: Float64 = 69, reference_frequency: Float64 = 440) -&gt; Float64\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_11","title":"Arguments","text":"<ul> <li>freq: <code>Float64</code>- reference_midi_note: <code>Float64</code> = <code>69</code>- reference_frequency: <code>Float64</code> = <code>440</code></li> </ul>"},{"location":"api/mmm_utils/functions/#returns_11","title":"Returns","text":"<p>Type: <code>Float64</code></p>"},{"location":"api/mmm_utils/functions/#mix","title":"mix","text":""},{"location":"api/mmm_utils/functions/#signature_12","title":"Signature","text":"<pre><code>mix(mut output: List[Float64], *lists: List[Float64])\n</code></pre>"},{"location":"api/mmm_utils/functions/#arguments_12","title":"Arguments","text":"<ul> <li>output: <code>List</code>- *lists: <code>List</code></li> </ul>"},{"location":"api/mmm_utils/functions/#sanitize","title":"sanitize","text":""},{"location":"api/mmm_utils/functions/#signature_13","title":"Signature","text":"<pre><code>sanitize[N: Int = 1](x: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_7","title":"Parameters","text":"<ul> <li>N: <code>Int</code></li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_13","title":"Arguments","text":"<ul> <li>x: <code>SIMD</code></li> </ul>"},{"location":"api/mmm_utils/functions/#returns_12","title":"Returns","text":"<p>Type: <code>SIMD</code></p>"},{"location":"api/mmm_utils/functions/#random_exp_float64","title":"random_exp_float64","text":"<p>Generates a random float64 value from an exponential distribution.</p>"},{"location":"api/mmm_utils/functions/#signature_14","title":"Signature","text":"<pre><code>random_exp_float64[N: Int = 1](min: SIMD[DType.float64, N], max: SIMD[DType.float64, N]) -&gt; SIMD[DType.float64, N]\n</code></pre>"},{"location":"api/mmm_utils/functions/#parameters_8","title":"Parameters","text":"<ul> <li>N: <code>Int</code> - Size of the SIMD vector - defaults to 1.</li> </ul>"},{"location":"api/mmm_utils/functions/#arguments_14","title":"Arguments","text":"<ul> <li>min: <code>SIMD</code> - The minimum value (inclusive).- max: <code>SIMD</code> - The maximum value (inclusive).</li> </ul>"},{"location":"api/mmm_utils/functions/#returns_13","title":"Returns","text":"<p>Type: <code>SIMD</code></p> <p>Documentation generated with <code>mojo doc</code> from Mojo version 0.25.6.0.dev2025090605</p>"},{"location":"contributing/","title":"Contributing to MMMAudio","text":"<p>Thank you for your interest in contributing to MMMAudio! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>See the README.md file in the repo's root directory for how to get MMMAudio up and running.</p>"},{"location":"contributing/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<ul> <li>Use type hints for all function signatures</li> <li>Use Google-style docstrings</li> </ul>"},{"location":"contributing/#mojo-code","title":"Mojo Code","text":"<ul> <li>Follow Mojo style conventions</li> <li>Use SIMD types for performance-critical code</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>All public APIs must be documented</li> <li>Include practical examples for each function</li> <li>Update documentation when changing functionality</li> <li>Consult the documentation examples/style-guides in <code>doc_generation/examples</code></li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and constructive in all interactions. We're building a welcoming community for audio developers of all skill levels.</p>"},{"location":"contributing/documentation/","title":"Documentation for MMMAudio Repo","text":"<p>This repo uses mkdocs to render code documentation files from Google-style docstrings in Python and Mojo files.</p>"},{"location":"contributing/documentation/#dependencies","title":"Dependencies","text":"<p>See root/requirements-docs.txt.</p>"},{"location":"contributing/documentation/#what-the-doc_generation-directory-contains","title":"What the <code>doc_generation</code> directory contains:","text":"<ul> <li>examples/: An example Python and Mojo file for how to put the in-source-file documentation into the respective language files. These shouldn't be modified, just use as a reference / style guide.</li> <li>static_docs/: This directory contains any documentation files that are not generated from source code or examples. This includes things like \"Getting Started\" and \"Contributing\". To edit this content, edit these Markdown files directly. This directory also maintains the directory structure that will be copied into the docs_md/ directory. The docs_md/ directory is the actual directory the mkdocs will look to to generate HTML from Markdown files, which is to say that the directory structure of the HTML files and website comes from docs_md/ which is copied form static_docs/, so maintaining this directory structure is important. You'll notice there are <code>index.md</code> files, these are the \"homepages\" for each directory (including the site's top level directory).</li> <li>templates/: Contains jinja2 templates that are used for rendering Markdown files.</li> <li>mojo_doc_template_jinja.md: Used to inject the contents of a <code>json</code> generated by <code>mojo doc</code> (which becomes a <code>dict</code> in <code>generate_docs.py</code>) into Markdown format.</li> <li>example_python_and_mojo_jinja.md: Template for making a page for each example in the root/examples directory. In order to render properly, this template (and the corresponding Python code in <code>generate_docs.py</code> expect each example to consist of two files: (1) a Python file and (2) a Mojo file with the same base name). Examples should be constructed using only two files using this convention.</li> <li>struct.md: A partial template for rendering a Mojo <code>struct</code>. This partial template is \"called\" in <code>mojo_doc_template_jinja.md</code>.</li> <li>init.py: Makes this directory a Python package so that the <code>main()</code> function of the <code>generate_docs.py</code> file can be called as a \"hook\"</li> <li>generate_docs.py: Python script that creates directory structure and generates Markdown files from jinja2 templates into the <code>docs_md</code> directory in preparation for mkdocs to use <code>docs_md</code> directory to create HTML (which ends up in the <code>root/docs</code> directory for GitHub Pages to use).</li> </ul>"},{"location":"contributing/documentation/#building-documentation-how-it-works","title":"Building Documentation / How It Works","text":"<p>Presented here in \"chronological\" order</p> <ol> <li>Make sure to install dependencies:</li> </ol> <pre><code>pip install -r requirements-docs.txt\n</code></pre> <ol> <li>In the root directory, run <code>mkdocs build</code></li> <li>The <code>mkdocs.yml</code> file indicates that the <code>on_pre_build</code> hook should run, which is the <code>main()</code> function of <code>generate_docs.py</code>. This script:</li> <li>Clears out the contents of the <code>docs_md</code> directory so there are no stale documents lingering there that would unintentionally be rendered by mkdocs</li> <li>Copies the contents of <code>static_docs</code> into <code>docs_md</code> to establish the directory structure and provide the Markdown files that are not generated from source or examples.</li> <li>Finds all the Mojo files in directories that contain source files (specified in <code>generate_docs.py</code> with the variable <code>HARDCODED_SOURCE_DIRS</code>) and for each file: (a) uses <code>mojo doc</code> to get a <code>json</code> string from standard out, (b) turn that string in to <code>dict</code>, (c) removes information from that <code>dict</code> that isn't worth rendering in the documentation, such as the methods <code>__init__</code> and <code>__repr__</code> as well as the argument <code>self</code>, (d) uses the remaining contents of the <code>dict</code> as context for rendering a Markdown file to document what is in the file. The Markdown file has the same basename as the Mojo file. Because the Mojo file basename corresponds to the way it appears in the documentation, each Mojo struct should live in its own file. This will make the documentation clearer to navigate on the documentation site. </li> <li>Looks in the <code>root/examples</code> directory and finds all the Python files. It assumes there will be a Mojo file of the same name. The script also assumes that each example consists of just the two files and that any other code that is needed can be imported from the MMMAudio core. This correspondence simplifies file management for rendering the examples into the documentation and makes the process of editing and creating examples clearer. The two files are both pasted into a Markdown file (using <code>example_python_and_mojo_jinja.md</code>) which is saved to the <code>docs_md/examples</code> directory.</li> <li>Once <code>generate_docs.py</code> is complete, <code>mkdocs</code> then build the site, putting all the HTML in the <code>docs</code> directory. </li> </ol>"},{"location":"contributing/documentation/#serve-locally","title":"Serve Locally","text":"<p>To preview the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>The documentation will be available at <code>http://localhost:8000</code>.</p>"},{"location":"contributing/documentation/#build-pdf","title":"Build PDF","text":"<p>A PDF version of the docs is automatically built when <code>mkdocs build</code> is run. To turn this off, remove the <code>with-pdf</code> plug-ing from the <code>mkdocs.yml</code> file.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section contains practical examples demonstrating how to use MMMAudio for various audio processing tasks.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":"<ul> <li>Default Graph: Basic audio graph setup</li> <li>In2Out: Simple input to output routing</li> </ul>"},{"location":"examples/#synthesis-examples","title":"Synthesis Examples","text":"<ul> <li>Many Oscillators: Multiple oscillator management</li> <li>Grains: Granular synthesis techniques</li> </ul>"},{"location":"examples/#effects-examples","title":"Effects Examples","text":"<ul> <li>Feedback Delays: Delay-based effects</li> <li>Pan Az: Spatial audio panning</li> </ul>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":"<ul> <li>MIDI Sequencer: MIDI-controlled sequencing</li> <li>Torch MLP: Neural network audio processing</li> <li>Record: Audio recording and playback</li> </ul>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>Most examples can be run directly with Python:</p> <pre><code>python examples/default.py\n</code></pre> <p>Or with Mojo for the .mojo examples:</p> <pre><code>mojo examples/Default_Graph.mojo\n</code></pre>"},{"location":"examples/Default_Graph/","title":"Default Graph","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Default_Graph/#default_graph","title":"Default_Graph","text":"<p>use this as a template for your own graphs</p>"},{"location":"examples/Default_Graph/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\n\n# instantiate and load the graph\nmmm_audio = MMMAudio(128, graph_name=\"Default_Graph\", package_name=\"examples\")\nmmm_audio.start_audio() \n\nfrom random import random\nmmm_audio.send_msg(\"osc_freq\", random() * 500 + 100 ) # set the frequency to a random value\n</code></pre>"},{"location":"examples/Default_Graph/#mojo-code","title":"Mojo Code","text":"<pre><code>\"\"\"use this as a template for your own graphs\"\"\"\n\nfrom mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\nfrom mmm_dsp.Osc import Osc\nfrom mmm_dsp.Filters import Lag\n\nstruct Default_Synth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  \n    var osc: Osc\n    var freq: Float64\n    var lag: Lag\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.osc = Osc(self.world_ptr)\n        self.freq = 440.0\n        self.lag = Lag(self.world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Default\")\n\n    fn next(mut self) -&gt; Float64:\n\n        self.get_msgs()\n        freq = self.lag.next(self.freq, 3)\n        return self.osc.next(freq[0]) * 0.1\n\n    fn get_msgs(mut self: Self):\n        # Get messages from the world\n        msg = self.world_ptr[0].get_msg(\"osc_freq\")\n        if msg:\n            self.freq = msg.value()[0]\n\n# there can only be one graph in an MMMAudio instance\n# a graph can have as many synths as you want\nstruct Default_Graph(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var synth: Default_Synth\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.synth = Default_Synth(self.world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Default_Graph\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 1]:\n\n        return self.synth.next()  # Get the next sample from the synth\n</code></pre>"},{"location":"examples/FeedbackDelays/","title":"Feedback Delays","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/FeedbackDelays/#feedbackdelays","title":"FeedbackDelays","text":"<p>use the mouse to control an overdriven feedback delay</p>"},{"location":"examples/FeedbackDelays/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\nmmm_audio = MMMAudio(128, graph_name=\"FeedbackDelays\", package_name=\"examples\")\n\nmmm_audio.start_audio() # start the audio thread - or restart it where it left off\nmmm_audio.stop_audio() # stop/pause the audio thread\n</code></pre>"},{"location":"examples/FeedbackDelays/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\nfrom mmm_dsp.Buffer import *\nfrom mmm_dsp.PlayBuf import *\nfrom mmm_dsp.Delays import *\nfrom mmm_utils.functions import *\n\nstruct DelaySynth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    var buffer: InterleavedBuffer  # Interleaved buffer for audio samples\n    var playBuf: PlayBuf\n    var delays: FBDelay[2]  # FBDelay for feedback delay effect\n    var lag: Lag[2]\n    var mouse_x: Float64\n    var mouse_y: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr  \n        self.buffer = InterleavedBuffer(self.world_ptr, \"resources/Shiverer.wav\")\n        self.playBuf = PlayBuf(self.world_ptr) \n        # FBDelay is initialized as 2 channel\n        self.delays = FBDelay[2](self.world_ptr) \n\n        self.lag = Lag[2](self.world_ptr)  # Initialize Lag with a default time constant\n\n        self.mouse_x = 0.0\n        self.mouse_y = 0.0\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n        self.get_msgs()  # Get messages from the world\n        var sample = self.playBuf.next[N=2](self.buffer, 0, 1.0, True)  # Read samples from the buffer\n\n        # sending one value to the 2 channel lag gives both lags the same parameters\n        # var del_time = self.lag.next(linlin(self.mouse_x, 0.0, 1.0, 0.0, self.buffer.get_duration()), 0.5)\n\n        # this is a version with the 2 value SIMD vector as input each delay with have its own del_time\n        var del_time = self.lag.next(SIMD[DType.float64, 2](\n            linlin(self.mouse_x, 0.0, 1.0, 0.0, self.buffer.get_duration()), \n            linlin(self.mouse_x, 0.0, 1.0, 0.0, self.buffer.get_duration()*0.9)\n        ), SIMD[DType.float64, 2](0.5, 0.5))\n\n        var feedback = SIMD[DType.float64, 2](self.mouse_y * 2.0, self.mouse_y * 2.1)\n\n        sample = self.delays.next(sample, del_time, feedback)*0.8\n\n        return sample\n\n    fn __repr__(self) -&gt; String:\n        return String(\"DelaySynth\")\n\n    fn get_msgs(mut self):\n        self.mouse_x = self.world_ptr[0].mouse_x\n        self.mouse_y = self.world_ptr[0].mouse_y\n\nstruct FeedbackDelays(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var delay_synth: DelaySynth  # Instance of the Oscillator\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.delay_synth = DelaySynth(world_ptr)  # Initialize the DelaySynth with the world instance\n\n    fn __repr__(self) -&gt; String:\n        return String(\"FeedbackDelays\")\n\n    fn next(mut self: FeedbackDelays) -&gt; SIMD[DType.float64, 2]:\n        return self.delay_synth.next()  # Return the combined output sample\n</code></pre>"},{"location":"examples/Grains/","title":"Grains","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Grains/#grains","title":"Grains","text":"<p>this uses the mouse to control granular playback of the buffer left and right moves around in the buffer. up and down controls rate of triggers.</p>"},{"location":"examples/Grains/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\nmmm_audio = MMMAudio(128, graph_name=\"Grains\", package_name=\"examples\")\n\nmmm_audio.start_audio() # start the audio thread - or restart it where it left off\nmmm_audio.stop_audio() # stop/pause the audio thread\n</code></pre>"},{"location":"examples/Grains/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\nfrom mmm_dsp.Buffer import *\nfrom mmm_dsp.PlayBuf import *\nfrom mmm_dsp.Osc import *\nfrom mmm_dsp.Filters import VAMoogLadder\nfrom mmm_utils.functions import linexp\nfrom random import random_float64\n\n# THE SYNTH\n\nstruct GrainSynth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var buffer: InterleavedBuffer\n\n    var num_chans: Int64\n\n    var tgrains: TGrains\n    var impulse: Impulse  \n    var start_frame: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr  \n\n        # interleaved buffer uses numpy to load a buffer into an interleaved array\n        self.buffer = InterleavedBuffer(self.world_ptr, \"resources/Shiverer.wav\")\n        self.num_chans = self.buffer.num_chans  \n\n        # it will try to free the interleaved buffer if you don't print here. gotta figure this out. this is either a bug by me or by modular.\n        print(\"Loaded buffer with \", self.buffer.get_num_frames(), \" frames and \", self.num_chans, \" channels.\")\n\n        self.tgrains = TGrains(self.world_ptr, 20)  \n        self.impulse = Impulse(self.world_ptr)  \n\n\n        self.start_frame = 0.0 \n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n\n        imp_freq = linlin(self.world_ptr[0].mouse_y, 0.0, 1.0, 5.0, 40.0)\n        var impulse = self.impulse.next(imp_freq, 1.0)  # Get the next impulse sample\n\n        start_frame = linlin(self.world_ptr[0].mouse_x, 0.0, 1.0, 0.0, self.buffer.get_num_frames())\n\n        # use the first channel of the buffer\n        var grains = self.tgrains.next(self.buffer, 0, impulse, 1, start_frame, 0.4, random_float64(-1.0, 1.0), 0.4)\n\n        # if you want to use both channels of the buffer, uncomment this and comment the line above\n        # with the 2 channel version, there will be 2 channels of output (in stereo), but no panning\n        # var grains = self.tgrains.next[N=2](self.buffer, 0, impulse, 1, start_frame, 0.4, random_float64(-1.0, 1.0), 0.4) \n\n        return grains\n\n\n    fn __repr__(self) -&gt; String:\n        return String(\"GrainSynth\")\n\n# THE GRAPH\n\nstruct Grains(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var grain_synth: GrainSynth  # Instance of the GrainSynth\n\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n        self.grain_synth = GrainSynth(world_ptr)  # Initialize the GrainSynth with the world instance\n\n    fn __repr__(self) -&gt; String:\n        return String(\"TGrains\")\n\n    fn next(mut self: Grains) -&gt; SIMD[DType.float64, 2]:\n        sample = self.grain_synth.next()\n\n        return sample  # Return the combined output sample\n</code></pre>"},{"location":"examples/In2Out/","title":"In2Out","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/In2Out/#in2out","title":"In2Out","text":"<p>This is the simples MMMAudio example. It routes input channels directly to output channels. It also demonstrates how to send a message to the graph to print the current input values to the REPL.</p>"},{"location":"examples/In2Out/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import *\n\n# this will list available audio devices\nlist_audio_devices()\n\nin_device = \"Fireface UFX+ (24059506)\"\nout_device = \"Fireface UFX+ (24059506)\"\n\n# or get some feedback\nin_device = \"MacBook Pro Microphone\"\nout_device = \"External Headphones\"\n\n# instantiate and load the graph\nmmm_audio = MMMAudio(128, num_input_channels=12, num_output_channels=12, in_device=in_device, out_device=out_device, graph_name=\"In2Out\", package_name=\"examples\")\nmmm_audio.start_audio()\n\n# print the current sample of inputs to the REPL\nmmm_audio.send_msg(\"print_inputs\")  \n\nmmm_audio.stop_audio()\n</code></pre>"},{"location":"examples/In2Out/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\n\n# this is the simplest possible\nstruct In2Out(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n    fn __repr__(self) -&gt; String:\n        return String(\"In2Out\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 16]:\n        self.get_msgs()\n\n        # the SIMD vector has to be a power of 2\n        output = SIMD[DType.float64, 16](0.0)\n\n        # whichever is smaller, the output or the sound_in - that number of values are copied to the output\n        smaller  = min(len(output), len(self.world_ptr[0].sound_in))\n        for i in range(smaller):\n            output[i] = self.world_ptr[0].sound_in[i]\n\n        return output  # Return the combined output samples\n\n    fn get_msgs(mut self: Self):\n        # a \"print_inputs\" message prints the current values held in the sound_in list in the world_ptr\n        msg = self.world_ptr[0].get_msg(\"print_inputs\")\n        if msg:\n            for i in range(self.world_ptr[0].num_in_chans):\n                print(\"input[\", i, \"] =\", self.world_ptr[0].sound_in[i])\n</code></pre>"},{"location":"examples/ManyOscillators/","title":"Many Oscillators","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/ManyOscillators/#manyoscillators","title":"ManyOscillators","text":"<p>Example showing how to use ManyOscillators.mojo with MMMAudio.</p> <p>You can change the number of oscillators dynamically by sending a 'set_num_pairs' message.</p>"},{"location":"examples/ManyOscillators/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\nmmm_audio = MMMAudio(128, graph_name=\"ManyOscillators\", package_name=\"examples\")\n\nmmm_audio.start_audio() # start the audio thread - or restart it where it left off\n\nmmm_audio.send_msg(\"set_num_pairs\", 2)  # set to 2 pairs of oscillators\n\nmmm_audio.send_msg(\"set_num_pairs\", 14)  # change to 4 pairs of oscillators\n\nmmm_audio.send_msg(\"set_num_pairs\", 50)  # change to 4 pairs of oscillators\n\nmmm_audio.stop_audio() # stop/pause the audio thread\n</code></pre>"},{"location":"examples/ManyOscillators/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\nfrom mmm_dsp.Osc import Osc\nfrom random import random_float64\nfrom mmm_dsp.Pan import Pan2\nfrom mmm_dsp.OscBuffers import OscBuffers\n\n# THE SYNTH\n\nstruct OscSynth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  \n    var oscs: Osc[2]  # An Osc instance with two internal Oscs\n    var osc_freqs: SIMD[DType.float64, 2] \n    var pan: Pan2\n    var pan_osc: Osc\n    var pan_freq: Float64\n    var vol_osc: Osc\n    var vol_osc_freq: Float64\n    var temp: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld], center_freq: Float64):\n        self.world_ptr = world_ptr\n        self.oscs = Osc[2](world_ptr)  # Initialize two Osc instances\n\n        self.pan = Pan2(world_ptr)\n        self.pan_osc = Osc(world_ptr)\n        self.pan_freq = random_float64(0.03, 0.1)\n\n        self.vol_osc = Osc(world_ptr)\n        self.vol_osc_freq = random_float64(0.05, 0.2)\n        self.osc_freqs = SIMD[DType.float64, 2](\n            center_freq + random_float64(1.0, 5.0),\n            center_freq - random_float64(1.0, 5.0)\n        )\n        self.temp = 0.0\n\n    fn __repr__(self) -&gt; String:\n        return String(\"OscSynth\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n\n        temp = self.oscs.next(self.osc_freqs, interp = 0, os_index = 0) \n\n        temp = temp * (self.vol_osc.next(self.vol_osc_freq) * 0.01 + 0.01)\n        temp2 = temp[0] + temp[1]\n\n        self.world_ptr[0].print(self.osc_freqs, \"freqs\", freq=1.0)\n\n        pan_loc = self.pan_osc.next(self.pan_freq)  # Get pan position\n\n        return self.pan.next(temp2, pan_loc)  # Pan the temp signal\n\n# THE GRAPH\n\nstruct ManyOscillators(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    var osc_synths: List[OscSynth]  # Instances of the Oscillator\n    var num_pairs: Int\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n        # initialize the list of oscillator pairs\n        self.osc_synths = List[OscSynth]()\n        # add 10 pairs to the list\n        self.num_pairs = 10\n        for _ in range(self.num_pairs):\n            self.osc_synths.append(OscSynth(self.world_ptr, random_exp_float64(100.0, 1000.0)))  \n\n    fn __repr__(self) -&gt; String:\n        return String(\"ManyOscillators\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n        self.get_msgs()\n\n        # sum all the stereo outs from the N oscillator pairs\n        sum = SIMD[DType.float64, 2](0.0, 0.0)\n        for i in range(self.num_pairs):\n            sum += self.osc_synths[i].next()\n\n        return sum\n\n    fn get_msgs(mut self):\n        # looking for a message that changes the number of osc pairs\n\n        num = self.world_ptr[0].get_msg(\"set_num_pairs\")\n        if num:\n            if num.value()[0] != self.num_pairs:\n                print(\"Changing number of osc pairs to:\", Int(num.value()[0]))\n                # adjust the list of osc synths\n                if Int(num.value()[0]) &gt; self.num_pairs:\n                    # add more\n                    for _ in range(Int(num.value()[0]) - self.num_pairs):\n                        self.osc_synths.append(OscSynth(self.world_ptr, random_exp_float64(100.0, 1000.0)))  \n                else:\n                    # remove some\n                    for _ in range(self.num_pairs - Int(num.value()[0])):\n                        _ = self.osc_synths.pop()\n            self.num_pairs = Int(num.value()[0])\n</code></pre>"},{"location":"examples/Midi_Sequencer/","title":"MIDI Sequencer","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Midi_Sequencer/#midi_sequencer","title":"Midi_Sequencer","text":""},{"location":"examples/Midi_Sequencer/#examples.Midi_Sequencer.trig_synth","title":"<code>trig_synth(wait)</code>  <code>async</code>","text":"<p>A counter coroutine</p> Source code in <code>examples/Midi_Sequencer.py</code> <pre><code>async def trig_synth(wait):\n    \"\"\"A counter coroutine\"\"\"\n    count_to = np.random.choice([7, 11, 13, 17]).item()\n    mult_seq = Pseq(list(range(1, count_to + 1)))\n    fund_seq = Pxrand([36, 37, 43, 42])\n    i = 0\n    fund = librosa.midi_to_hz(fund_seq.next())\n    while True:\n        pitch = mult_seq.next() * fund\n        mmm_audio.send_msg(\"t_trig\", 1.0)\n        mmm_audio.send_msg(\"trig_seq_freq\", pitch)\n        await asyncio.sleep(wait)\n        i = (i + 1) % count_to\n        if i == 0:\n            fund = librosa.midi_to_hz(fund_seq.next())\n            count_to = np.random.choice([7, 11, 13, 17]).item()\n            mult_seq = Pseq(list(range(1, count_to + 1)))\n</code></pre>"},{"location":"examples/Midi_Sequencer/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\n# instantiate and load the graph\nmmm_audio = MMMAudio(128, graph_name=\"Midi_Sequencer\", package_name=\"examples\")\nmmm_audio.start_audio()\n\n# this next chunk of code is all about using a midi keyboard to control the synth---------------\n\n# the python host grabs the midi and sends the midi messages to the mojo audio engine\n\nimport mido\nimport time\nimport threading\n\n# find your midi devices\nmido.get_input_names()\n\n# open your midi device - you may need to change the device name\nin_port = mido.open_input('Oxygen Pro Mini USB MIDI')\n\ndef start_midi():\n    while True:\n        for msg in in_port.iter_pending():\n            # print(msg)\n            mmm_audio.send_midi(msg)\n        time.sleep(0.01) # Small delay to prevent busy-waiting\n\nmidi_thread = threading.Thread(target=start_midi, daemon=True)\n# once you start the midi_thread, it should register note_on, note_off, cc, etc from your device and send them to mmm\nmidi_thread.start()\nmidi_thread.stop()\n\n# this chunk of code shows how to use the sequencer to trigger notes in the mmm_audio engine\n\n# the scheduler can also sequence notes\nfrom mmm_src.Patterns import * # some sc style patterns\nimport numpy as np\nimport asyncio\nimport librosa\n\nscheduler = mmm_audio.scheduler\n\nasync def trig_synth(wait):\n    \"\"\"A counter coroutine\"\"\"\n    count_to = np.random.choice([7, 11, 13, 17]).item()\n    mult_seq = Pseq(list(range(1, count_to + 1)))\n    fund_seq = Pxrand([36, 37, 43, 42])\n    i = 0\n    fund = librosa.midi_to_hz(fund_seq.next())\n    while True:\n        pitch = mult_seq.next() * fund\n        mmm_audio.send_msg(\"t_trig\", 1.0)\n        mmm_audio.send_msg(\"trig_seq_freq\", pitch)\n        await asyncio.sleep(wait)\n        i = (i + 1) % count_to\n        if i == 0:\n            fund = librosa.midi_to_hz(fund_seq.next())\n            count_to = np.random.choice([7, 11, 13, 17]).item()\n            mult_seq = Pseq(list(range(1, count_to + 1)))\n\nscheduler.sched(trig_synth(0.1))\n\nscheduler.stop_routs()\n\nmmm_audio.stop_audio()\nmmm_audio.start_audio()\n</code></pre>"},{"location":"examples/Midi_Sequencer/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\n\nfrom mmm_utils.functions import *\nfrom mmm_dsp.Osc import *\nfrom mmm_dsp.Filters import *\nfrom mmm_dsp.Env import Env\n\nfrom mmm_src.MMMTraits import *\n\n\nstruct TrigSynthVoice(Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  # Pointer to the MMMWorld instance\n\n    var env: Env\n\n    var mod: Osc\n    var car: Osc\n    var lag: Lag\n\n    var trig: Float64\n    var freq: Float64\n\n    var vol: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n        self.mod = Osc(self.world_ptr)\n        self.car = Osc(self.world_ptr)\n        self.lag = Lag(self.world_ptr)\n\n        self.env = Env(self.world_ptr)\n\n        self.trig = 0.0\n        self.freq = 100.0\n        self.vol = 1.0\n\n    fn next(mut self) -&gt; Float64:\n        if not self.env.is_active and self.trig &lt;= 0.0:\n            return 0.0  # Return 0 if the envelope is not active and no trigger\n        else:\n            var mod_value = self.mod.next(self.freq*1.5)  # Get the next value from the modulator\n            var env = self.env.next([0.0, 1.0, 0.75, 0.75, 0.0], [0.01, 0.1, 0.2, 0.5], [1.0], 0, self.trig)\n            var mod_mult = linlin(env, 0.0, 1.0, 0.0, 0.25) # self.lag.next(linlin(self.mouse_x, 0.0, 1.0, 0.0, 8.0), 0.05)\n            var car_value = self.car.next(self.freq, mod_value * mod_mult, osc_type=2, os_index=1)  # Get the next value from the carrier\n            car_value = car_value * 0.1 * env * self.vol\n\n            return car_value\n\nstruct TrigSynth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  # Pointer to the MMMWorld instance\n\n    var voices: List[TrigSynthVoice]\n    var current_voice: Int64\n    var trig: Float64\n    var freq: Float64\n    var num_voices: Int64\n    var note_ons: List[List[Int64]]\n    var ccs: List[List[Int64]]\n\n    var svf: SVF\n    var filt_lag: Lag\n    var filt_freq: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld], num_voices: Int64 = 8):\n        self.world_ptr = world_ptr\n        self.trig = 0.0\n        self.freq = 100.0\n        self.num_voices = num_voices\n        self.current_voice = 0\n\n        self.note_ons = List[List[Int64]]()\n        self.ccs = List[List[Int64]]()\n\n        self.voices = List[TrigSynthVoice]()\n        for _ in range(self.num_voices):\n            self.voices.append(TrigSynthVoice(self.world_ptr))\n\n        self.svf = SVF(self.world_ptr)\n        self.filt_lag = Lag(self.world_ptr)\n        self.filt_freq = 1000.0\n\n    fn __repr__(self) -&gt; String:\n        return String(\"OscSynth\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n        self.get_msgs()\n\n        var out = 0.0\n\n        for note_on in self.note_ons:\n            print(note_on[0], note_on[1], note_on[2], end = \"\\n\")\n            self.current_voice = (self.current_voice + 1) % self.num_voices\n            self.voices[self.current_voice].vol = Float64(note_on[2]) / 127.0\n            self.voices[self.current_voice].trig = 1.0\n            self.voices[self.current_voice].freq = midicps(note_on[1])\n        self.note_ons.clear()\n\n        # looking for midi cc on cc 34\n        # this will control the frequency of the filter\n        for cc in self.ccs:\n            if cc[1] == 34:  # Assuming CC 34 is for filter frequency\n                self.filt_freq = linlin(Float64(cc[2]), 0.0, 127.0, 20.0, 1000.0)  # Map CC value to frequency range\n\n        if self.trig &gt; 0.0:\n            self.current_voice = (self.current_voice + 1) % self.num_voices\n            self.voices[self.current_voice].trig = self.trig\n            self.voices[self.current_voice].freq = self.freq\n\n        # get the output of all the synths and reset the of the current voice (after getting audio)\n        for i in range(len(self.voices)):\n            out += self.voices[i].next()\n            self.trig = 0.0\n            self.voices[i].trig = 0.0  # Reset the trigger for the next iteration\n\n        out = self.svf.lpf(out, self.filt_lag.next(self.filt_freq, 0.1), 2.0) * 0.6\n\n        return out\n\n    fn get_msgs(mut self: Self):\n        # calls to get_msg and get_midi return an Optional type\n        # so you must get the value, then test the value to see if it exists, before using the value\n        # get_msg returns a single list of values while get_midi returns a list of lists of values\n\n        trig = self.world_ptr[0].get_msg(\"t_trig\") # trig will be an Optional\n        if trig: # if it trig is None, we do nothing\n            self.trig = trig.value()[0]\n        freq = self.world_ptr[0].get_msg(\"trig_seq_freq\")\n        if freq:\n            self.freq = freq.value()[0]\n        note_ons = self.world_ptr[0].get_midi(\"note_on\",-1, -1)  # Get all note on messages\n        if note_ons:\n            self.note_ons = note_ons.value().copy()\n\n        ccs = self.world_ptr[0].get_midi(\"control_change\",-1, -1)\n        if ccs:\n            self.ccs = ccs.value().copy()\n\nstruct Midi_Sequencer(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    var output: List[Float64]  # Output buffer for audio samples\n\n    var trig_synth: TrigSynth  # Instance of the Oscillator\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.output = List[Float64](0.0, 0.0)  # Initialize output list\n\n        self.trig_synth = TrigSynth(world_ptr)  # Initialize the TrigSynth with the world instance\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Midi_Sequencer\")\n\n    fn next(mut self: Midi_Sequencer) -&gt; SIMD[DType.float64, 2]: \n        return self.trig_synth.next()  # Return the combined output sample\n</code></pre>"},{"location":"examples/OleDusty/","title":"Ole Dusty","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/OleDusty/#oledusty","title":"OleDusty","text":""},{"location":"examples/OleDusty/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio \n\n# instantiate and load the graph\nmmm_audio = MMMAudio(128, graph_name=\"OleDusty\", package_name=\"examples\")\nmmm_audio.start_audio()\n</code></pre>"},{"location":"examples/OleDusty/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_dsp.Osc import Dust\nfrom mmm_utils.functions import *\nfrom mmm_dsp.Filters import *\n\n# THE SYNTH\n\nstruct Dusty(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  \n    var dust: Dust[2] \n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.dust = Dust[2](world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"OleDusty\")\n\n    fn next(mut self, freq: Float64) -&gt; SIMD[DType.float64, 2]:\n\n        out = self.dust.next(freq)\n\n        # uncomment below for use the phase of the Dust oscillator instead of the impulse\n        # out = self.dust.get_phase()\n\n        return out\n\n# THE GRAPH\n\nstruct OleDusty(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  \n    var dusty: Dusty\n    var reson: Reson[2]\n    var freq: Float64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.dusty = Dusty(world_ptr)\n        self.reson = Reson[2](world_ptr)\n        self.freq = 20.0\n\n    fn __repr__(self) -&gt; String:\n        return String(\"OleDusty\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n\n        freq = linexp(self.world_ptr[0].mouse_y, 0.0, 1.0, 100.0, 2000.0)\n\n        out = self.dusty.next(linlin(self.world_ptr[0].mouse_x, 0.0, 1.0, 5.0, 200.0))\n\n        # there is really no difference between ugens, synths, graphs\n        # thus there is no reason you can't process the output of a synth directly in the graph\n        # the reson filter uses SIMD to run 2 filters in parallel, each processing a channel of the dusty synth\n        out = self.reson.hpf(out, freq, 10.0, 1.0)  # apply a bandpass filter to the output of the Dusty synth\n\n        return out\n</code></pre>"},{"location":"examples/Pan_Az/","title":"Pan Az","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Pan_Az/#pan_az","title":"Pan_Az","text":""},{"location":"examples/Pan_Az/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\n\n\n# instantiate and load the graph\n\n# PanAz is not quite right as of yet\nmmm_audio = MMMAudio(128, graph_name=\"Pan_Az\", package_name=\"examples\", num_output_channels=5)\nmmm_audio.start_audio() \n\nmmm_audio.stop_audio()\n\nfrom random import random\nmmm_audio.send_msg(\"osc_freq\", random() * 500 + 100 ) # set the frequency to a random value\n</code></pre>"},{"location":"examples/Pan_Az/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\nfrom mmm_dsp.Osc import Phasor, Osc\nfrom mmm_dsp.Pan import PanAz\n\nstruct PanAz_Synth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]  \n    var osc: Osc\n    var freq: Float64\n\n    var pan_osc: Phasor\n    var pan_az: PanAz\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.osc = Osc(self.world_ptr)\n        self.freq = 440.0\n\n        self.pan_osc = Phasor(self.world_ptr)\n        self.pan_az = PanAz(self.world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Default\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 8]:\n\n        self.get_msgs()\n\n        # PanAz needs to be given a SIMD size that is a power of 2, in this case [8], but the speaker size can be anything smaller than that\n        panned = self.pan_az.next[8](self.osc.next(self.freq, osc_type=2), self.pan_osc.next(0.1), 2, 2) * 0.1\n\n        return panned\n\n    fn get_msgs(mut self: Self):\n        # Get messages from the world\n        msg = self.world_ptr[0].get_msg(\"osc_freq\")\n        if msg:\n            self.freq = msg.value()[0]\n\n# there can only be one graph in an MMMAudio instance\n# a graph can have as many synths as you want\nstruct Pan_Az(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var synth: PanAz_Synth\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.synth = PanAz_Synth(self.world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"PanAz\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 8]:\n\n        sample = self.synth.next()  # Get the next sample from the synth\n\n        # the output will pan to the number of channels available \n        # if there are fewer than 5 channels, only those channels will be output\n        return sample  # Return the combined output samples\n</code></pre>"},{"location":"examples/PlayBuf/","title":"PlayBuf","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/PlayBuf/#playbuf","title":"PlayBuf","text":""},{"location":"examples/PlayBuf/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\nimport asyncio\nimport threading\n\n\nmmm_audio = MMMAudio(128, graph_name=\"PlayBuf_Graph\", package_name=\"examples\")\n\nmmm_audio.start_audio() # start the audio thread - or restart it where it left off\n\n# this example uses open sound control to control PlayBuf's playback speed and VAMoogFilter's cutoff frequency\n# there is a simple touchosc patch provided for control\n# it is looking for /fader1 and /fader2 on port 5005; these can be adjusted\n# Start the OSC server on its own thread\n# this is a bug, but this thread has to start after audio or audio won't start\nthread = threading.Thread(target=asyncio.run, args=(mmm_audio.start_osc_server(5005),), daemon=True)\nthread.start()\n\n# if touch_osc isn't available you can also send the messages directly\nmmm_audio.send_msg(\"/fader1\", 0.5) # fader value is mapped exponentially between 0.25 and 4\nmmm_audio.send_msg(\"/fader1\", 0.25) \n\nmmm_audio.send_msg(\"/fader2\", 0.5) # fader value is mapped exponentially between 20 and 20000\nmmm_audio.send_msg(\"/fader2\", 1) \n\nmmm_audio.stop_audio() # stop/pause the audio thread\n</code></pre>"},{"location":"examples/PlayBuf/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_src.MMMTraits import *\nfrom mmm_utils.functions import *\nfrom mmm_dsp.Filters import Lag\n\nfrom mmm_dsp.Buffer import *\nfrom mmm_dsp.PlayBuf import *\nfrom mmm_dsp.Filters import VAMoogLadder\n\nstruct BufSynth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld] \n    var buffer: InterleavedBuffer\n\n    var num_chans: Int64\n\n    var play_buf: PlayBuf\n    var playback_speed: Float64\n\n    var moog: VAMoogLadder[2]\n    var lpf_freq: Float64\n    var lpf_freq_lag: Lag\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr \n\n        # load the audio buffer \n        self.buffer = InterleavedBuffer(self.world_ptr, \"resources/Shiverer.wav\")\n        self.num_chans = self.buffer.num_chans  \n\n        # without printing this, the compiler wants to free the buffer for some reason\n        print(\"Loaded buffer with\", self.buffer.num_chans, \"channels and\", self.buffer.num_frames, \"frames.\")\n\n        self.playback_speed = 1.0\n\n        self.play_buf = PlayBuf(self.world_ptr)\n\n        self.moog = VAMoogLadder[2](self.world_ptr)\n        self.lpf_freq = 20000.0\n        self.lpf_freq_lag = Lag(world_ptr)\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n        self.get_msgs()\n\n        out = self.play_buf.next[N=2](self.buffer, 0, self.playback_speed, True)\n\n        freq = self.lpf_freq_lag.next(self.lpf_freq, 0.1)\n        out = self.moog.next(out, freq, 1.0, 1)\n        return out\n\n    fn __repr__(self) -&gt; String:\n        return String(\"BufSynth\")\n\n    fn get_msgs(mut self: Self):\n        # calls to get_msg and get_midi return an Optional type\n        # so you must get the value, then test the value to see if it exists, before using the value\n        # get_msg returns a single list of values while get_midi returns a list of lists of values\n\n        fader1 = self.world_ptr[0].get_msg(\"/fader1\") # fader1 will be an Optional\n        if fader1: # if fader1 is None, we do nothing\n            self.playback_speed = linexp(fader1.value()[0], 0.0, 1.0, 0.25, 4.0)\n        fader2 = self.world_ptr[0].get_msg(\"/fader2\") # fader2 will be an Optional\n        if fader2: # if fader2 is None, we do nothing\n            freq = linexp(fader2.value()[0], 0.0, 1.0, 20.0, 20000.0)\n            self.lpf_freq = freq\n\nstruct PlayBuf_Graph(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    var buf_synth: BufSynth  # Instance of the GrainSynth\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n        self.buf_synth = BufSynth(world_ptr)  \n\n    fn __repr__(self) -&gt; String:\n        return String(\"PlayBuf_Graph\")\n\n    fn next(mut self: PlayBuf_Graph) -&gt; SIMD[DType.float64, 2]:\n        #return SIMD[DType.float64, 2](0.0)\n        return self.buf_synth.next()  # Return the combined output sample\n</code></pre>"},{"location":"examples/Record/","title":"Record","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Record/#record","title":"Record","text":""},{"location":"examples/Record/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import *\nlist_audio_devices()\n\nin_device = \"Fireface UFX+ (24059506)\"\nout_device = \"Fireface UFX+ (24059506)\"\n\nin_device = \"MacBook Pro Microphone\"\nout_device = \"External Headphones\"\n\n\n\n# instantiate and load the graph\nmmm_audio = MMMAudio(128, num_input_channels=12, num_output_channels=12, in_device=in_device, out_device=out_device, graph_name=\"Record\", package_name=\"examples\")\n\n# the default input channel (in the Record_Synth) is 0, but you can change it to \nmmm_audio.send_msg(\"set_input_chan\", 0) \nmmm_audio.start_audio() \n\n\n\nmmm_audio.send_msg(\"print_inputs\")\n\n# this program is looking for midi note_on and note_off from note 48, so we prepare the keyboard to send messages to mmm_audio:\n\nimport mido\nimport time\nimport threading\n\n# find your midi devices\nmido.get_input_names()\n\n# open your midi device - you may need to change the device name\nin_port = mido.open_input('Oxygen Pro Mini USB MIDI')\n\ndef start_midi():\n    while True:\n        for msg in in_port.iter_pending():\n            print(msg)\n            mmm_audio.send_midi(msg)\n        time.sleep(0.01) # Small delay to prevent busy-waiting\n\nmidi_thread = threading.Thread(target=start_midi, daemon=True)\n# once you start the midi_thread, it should register note_on, note_off, cc, etc from your device and send them to mmm\nmidi_thread.start()\n\n\nmidi_thread.stop()\n\nmmm_audio.stop_audio()\n</code></pre>"},{"location":"examples/Record/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\nfrom mmm_dsp.Buffer import *\nfrom mmm_dsp.RecordBuf import RecordBuf\nfrom mmm_dsp.PlayBuf import PlayBuf\nfrom mmm_dsp.Env import min_env\nfrom mmm_dsp.Filters import Lag\n\nimport time\nfrom math import floor\n\nfrom mmm_dsp.Osc import Osc\n\nstruct Record_Synth(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var buf_dur: Float64\n    var buffer: Buffer\n    var is_recording: Float64\n    var is_playing: Float64\n    var playback_speed: Float64\n    var trig: Float64\n    var write_pos: Int64 \n    var record_buf: RecordBuf\n    var play_buf: PlayBuf\n    var note_ons: List[List[Int64]]\n    var note_offs: List[List[Int64]]\n    var note_time: Float64\n    var lag: Lag\n    var end_frame: Float64\n    var input_chan: Int64\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.buf_dur = 10.0  # seconds\n        self.buffer = Buffer(1, Int64(self.world_ptr[0].sample_rate*self.buf_dur), self.world_ptr[0].sample_rate)\n        self.is_recording = 0.0\n        self.is_playing = 0.0\n        self.trig = 0.0\n        self.playback_speed = 1.0\n        self.record_buf = RecordBuf(world_ptr)\n        self.play_buf = PlayBuf(world_ptr)\n        self.write_pos = 0\n        self.note_ons = List[List[Int64]]()\n        self.note_offs = List[List[Int64]]()\n        self.note_time = 0.0\n        self.end_frame = 0.0\n        self.lag = Lag(world_ptr)\n        self.input_chan = 0 \n\n    fn __repr__(self) -&gt; String:\n        return String(\"Record_Synth\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 1]:\n        self.get_msgs()\n\n        for note_on in self.note_ons:\n            print(note_on[0], note_on[1], note_on[2], end = \"\\n\")\n            if note_on[1] == 48:  \n                self.note_time = time.perf_counter()\n                self.write_pos = 0\n                self.is_recording = 1.0\n                self.is_playing = 0.0\n                self.trig = 0.0\n                print(\"Recording started\")\n        self.note_ons.clear()\n\n        for note_off in self.note_offs:\n            if note_off[1] == 48:  # C4 to stop recording\n                self.note_time = min(time.perf_counter() - self.note_time, self.buf_dur)\n                self.end_frame = floor(self.note_time*self.world_ptr[0].sample_rate)\n                print(self.note_time, self.end_frame/self.world_ptr[0].sample_rate)\n                self.note_time = self.end_frame / self.world_ptr[0].sample_rate\n                print(\"Recorded duration:\", self.note_time, \"seconds\")\n                self.is_recording = 0.0\n                print(\"Recording stopped. Now playing.\")\n                self.is_playing = 1.0\n                self.trig = 1.0\n                self.write_pos = 0\n\n        self.note_offs.clear()\n\n        # this code does the actual recording, placing the next sample into the buffer\n        # my audio interface has audio in on channel 9, so I use self.world_ptr[0].sound_in[8]\n        if self.is_recording:\n            # the sound_in List in the world_ptr holds the audio in data for the current sample, so grab it from there.\n            self.buffer.write(self.world_ptr[0].sound_in[self.input_chan], self.write_pos)\n            self.write_pos += 1\n            if self.write_pos &gt;= Int(self.buffer.num_frames):\n                self.is_recording = 0.0\n                print(\"Recording stopped: buffer full\")\n                self.is_playing = 1.0\n                self.trig = 1.0\n                self.write_pos = 0\n\n        out = self.play_buf.next(self.buffer, 0, self.playback_speed, True, self.trig, start_frame = 0, end_frame = self.end_frame)\n\n        self.world_ptr[0].print(String(self.play_buf.get_win_phase()), String(self.play_buf.get_phase()))\n\n        out = out * self.is_playing * min_env(self.play_buf.get_win_phase(), self.note_time, 0.01)\n\n        return out\n\n    fn get_msgs(mut self: Self):\n        # Get messages from the world\n        msg = self.world_ptr[0].get_msg(\"print_inputs\")\n        if msg:\n            for i in range(self.world_ptr[0].num_in_chans):\n                print(\"input[\", i, \"] =\", self.world_ptr[0].sound_in[i])\n        msg = self.world_ptr[0].get_msg(\"start_recording\")\n        if msg:\n            self.write_pos = 0\n            self.is_recording = 1.0\n            self.is_playing = 0.0\n            self.trig = 0.0\n        msg = self.world_ptr[0].get_msg(\"set_input_chan\")\n        if msg:\n            chan = Int64(msg.value()[0])\n            if chan &gt;= 0 and chan &lt; self.world_ptr[0].num_in_chans:\n                self.input_chan = chan\n                print(\"Setting input channel to\", chan)\n        note_ons = self.world_ptr[0].get_midi(\"note_on\",-1, -1)  # Get all note on messages\n        if note_ons:\n            self.note_ons = note_ons.value().copy()\n        note_offs = self.world_ptr[0].get_midi(\"note_off\",-1, -1)  # Get all note off messages\n        if note_offs:\n            self.note_offs = note_offs.value().copy()\n\n# there can only be one graph in an MMMAudio instance\n# a graph can have as many synths as you want\nstruct Record(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n\n    var synth: Record_Synth\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n        self.synth = Record_Synth(self.world_ptr)\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Record\")\n\n    fn next(mut self) -&gt; SIMD[DType.float64, 2]:\n        sample = self.synth.next()\n        # print(\"sample:\", sample)\n        return sample\n</code></pre>"},{"location":"examples/Torch_MLP/","title":"Torch MLP","text":"<p>For more information about the examples, such as how the Python and Mojo files interact with each other, see the Examples Overview</p>"},{"location":"examples/Torch_MLP/#torch_mlp","title":"Torch_MLP","text":"<p>this examples uses a Torch MLP model to control a 16 parameter synth to play the synth, just hang out in the top 4 lines of code and play with the mouse</p> <p>you can also train the synth by creating any number of input/output pairs and making a new training</p>"},{"location":"examples/Torch_MLP/#python-code","title":"Python Code","text":"<pre><code>from mmm_src.MMMAudio import MMMAudio\nfrom random import random\n\nmmm_audio = MMMAudio(128, graph_name=\"Torch_MLP\", package_name=\"examples\")\n\nmmm_audio.start_audio() # start the audio thread - or restart it where it left off\n\nmmm_audio.stop_audio()  # stop/pause the mojo thread\n\n\n# below is the code to make a new training --------------------------------\n\n\n# if you make a new training below, you can load it into the synth\nmmm_audio.send_text_msg(\"load_mlp_training\", \"examples/nn_trainings/model_traced.pt\")  \n\n\n# toggle inference off so you can set the synth values directly\nmmm_audio.send_msg(\"toggle_inference\", 1.0)\n\nout_size = 16\n\ndef make_setting():\n    setting = []\n    for i in range(out_size):\n        setting.append(random())\n        mmm_audio.send_msg(\"model_output\" + str(i), setting[i])\n\n    return setting\n\noutputs = make_setting()\n\nX_train_list = []\ny_train_list = []\n\nfor i in range(len(y_train_list)):\n    print(f\"Element {i}: {X_train_list[i]}\")\n    print(f\"Element {i}: {y_train_list[i]}\")\n\n# when you like a setting add an input and output pair\n# this is assuming you are training on 4 pairs of data points\nX_train_list.append([0,0])\ny_train_list.append(outputs)\n\nX_train_list.append([0,1])\ny_train_list.append(outputs)\n\nX_train_list.append([1,1])\ny_train_list.append(outputs)\n\nX_train_list.append([1,0])\ny_train_list.append(outputs)\n\nlearn_rate = 0.001\nepochs = 5000\n\nlayers = [ [ 64, \"relu\" ], [ 64, \"relu\" ], [ out_size, \"sigmoid\" ] ]\n\nfrom mmm_utils.mlp_trainer import train_nn\n\ntrain_nn(X_train_list, y_train_list, layers, learn_rate, epochs, \"examples/nn_trainings/model_traced.pt\")\n</code></pre>"},{"location":"examples/Torch_MLP/#mojo-code","title":"Mojo Code","text":"<pre><code>from mmm_src.MMMWorld import MMMWorld\nfrom mmm_utils.functions import *\nfrom mmm_src.MMMTraits import *\n\n# THE SYNTH - is imported from TorchSynth.mojo in this directory\nfrom .TorchSynth import TorchSynth\n\n# THE GRAPH\n\nstruct Torch_MLP(Representable, Movable, Copyable):\n    var world_ptr: UnsafePointer[MMMWorld]\n    var torch_synth: TorchSynth  # Instance of the TorchSynth\n\n    fn __init__(out self, world_ptr: UnsafePointer[MMMWorld]):\n        self.world_ptr = world_ptr\n\n        self.torch_synth = TorchSynth(world_ptr)  # Initialize the TorchSynth with the world instance\n\n    fn __repr__(self) -&gt; String:\n        return String(\"Torch_MLP\")\n\n    fn next(mut self: Torch_MLP) -&gt; SIMD[DType.float64, 2]:\n\n        return self.torch_synth.next()\n</code></pre>"}]}